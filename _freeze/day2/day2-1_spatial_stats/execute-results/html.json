{
  "hash": "f45e8ae65f01d22148425cc9728b5ab0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exercise 1\"\neditor: source\neditor_options: \n  chunk_output_type: inline\nbibliography: ../references.bib\n---\n\n## Learning objectives\n\n- Learn the basic principles of exploratory spatial statistics\n- Compute and visualise local and global measures of spatial autocorrelation\n- Compare spatial statistics measures across samples using linear mixed models\n- This chapter is based on the `OSTA` online book chapter on spatial statistics and uses heavily the `Voyager` spatial statistics library [@moses2023voyager]\n\n## Libraries\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"SpatialExperiment\")\nlibrary(\"ggplot2\")\nlibrary(\"Voyager\")\nlibrary(\"HDF5Array\")\nlibrary(\"tidyr\")\nlibrary(\"dplyr\")\nlibrary(\"lme4\")\nlibrary(\"lmerTest\")\nset.seed(1234)\n```\n:::\n\n\n## Load data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the SpatialExperiment objectq\nspe <- loadHDF5SummarizedExperiment(dir=\"results/day1\", prefix=\"01.1_spe\")\n```\n:::\n\n\nIn order to use the big spatial statistics library `sf` we convert the `SpatialExperiment` object into a `SpatialFeatureExperiment` object [@Moses2025.02.24.640007]. In addition to the `SpatialExperiment` object it contains simple feature categories such as `Geometries` and `Graphs`. In this 10x Visium Dataset the `Geometries` stored are the coordinates of the spots\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- toSpatialFeatureExperiment(spe)\nsfe\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SpatialFeatureExperiment \ndim: 18085 14207 \nmetadata(2): resources spatialList\nassays(1): counts\nrownames(18085): SAMD11 NOC2L ... MT-ND6 MT-CYB\nrowData names(3): ID Symbol Type\ncolnames(14207): s_016um_00144_00175-1 s_016um_00204_00145-1 ...\n  s_016um_00193_00227-1 s_016um_00109_00223-1\ncolData names(6): barcode in_tissue ... bin_size sample_id\nreducedDimNames(0):\nmainExpName: Gene Expression\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nsample01: \n```\n\n\n:::\n:::\n\n\n## Data modalities of spatial statistics\n\nIn spatial transcriptomics we differentiate between imaging-based and sequencing-based technologies which give rise to very different _data modalities_ [@rao2021exploring].  \n\n![Data Modalities in Spatial Transcriptomics [@emons2025harnessing]](https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/nar/53/17/10.1093_nar_gkaf870/1/gkaf870fig1.jpeg?Expires=1766403187&Signature=WxVqrLv3B2ktSO5UWsRogBTtrwQeC3Ol-gM090kNJc8hAakLbV1v~BmiBJ5ae-810EciaTYjbNSvPwAGSzaWQXbh9qSOf4jjkNwJsMp2JEI77MoADpxGWvO17H4PUrzfaRlDZK82fc~Ik2GchhlLaKJvQWAMvIKEAdSwrB74D~sbAKqTL1bngu3xL-Ta4x3254JJJbSdAeHbmXH1e8jpeTTFri63iYHI3yUkhJAYhltRKwlfhCkwO2F7Hj1EcwPrTKJK~oFe2igeODcCkpnpvRqZDgAI3ImcF52nGksXGzqXQTO72RPolepCA1cVdGCcQ8K-VUjTGnsB8Ide89-gJw__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA)\n\nOur dataset was acquired using 10x Visium HD. The data modality of this technology is best described by a _regular lattice_. This means that the observations are taken at regularly spaced intervals. This is very different to imaging-based approaches where observations are due to a stochastic data generating process, which is related to some underlying biological mechanism. \n\nWith spots of 2um^2, Visium HD can provide subcellular resolution. We can segment cells from this regular lattice of pixels and approximate the cells by their centroid. This in turn can be described as an _irregular lattice_ of the cell types in space or even be analysed as a point process of the cell centroid locations. \n\nIn what follows we will focus on analysing the regular lattice of the pixel measurements with techniques from lattice data analysis.\n\n## Preprocessing and neighbourhood defintion\n\nWe note that the counts in our `SpatialFeatureExperiment` object are still raw counts therefore we will log normalise them with `scuttle::logNormCounts()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# identify mitochondrial genes\ngn <- rowData(sfe)$Symbol\nmt <- grepl(\"^MT-\", gn, ignore.case = TRUE)\ntable(mt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmt\nFALSE  TRUE \n18074    11 \n```\n\n\n:::\n\n```{.r .cell-code}\n# remove them\nsfe <- sfe[!mt, ]\n\n#log-normalise the counts\nsfe <- scuttle::logNormCounts(sfe)\nsfe\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SpatialFeatureExperiment \ndim: 18074 14207 \nmetadata(2): resources spatialList\nassays(2): counts logcounts\nrownames(18074): SAMD11 NOC2L ... EIF1AY DAZ2\nrowData names(3): ID Symbol Type\ncolnames(14207): s_016um_00144_00175-1 s_016um_00204_00145-1 ...\n  s_016um_00193_00227-1 s_016um_00109_00223-1\ncolData names(7): barcode in_tissue ... sample_id sizeFactor\nreducedDimNames(0):\nmainExpName: Gene Expression\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nsample01: \n```\n\n\n:::\n:::\n\n\nNow, we notice a `logcounts` assay in our object.\n\nNext, we will define a neighbourhood on which we want to compute spatial statistics metrics. In 10x Visium it is very natural to consider the direct neigbours of hexagonal visium lattice. We do this with the function `Voyager::findVisiumGraph()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolGraph(sfe, \"visium\") <- findVisiumGraph(sfe)\ncolGraph(sfe, \"binary\") <- findVisiumGraph(sfe, style = \"B\")\n\nplotColGraph(sfe,\n  colGraphName = \"visium\"\n) + theme_void()\n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-5-1.png){width=672}\n:::\n:::\n\n\nWe notice two things:\n\n- The $y$-coordinate is flipped compared to the image. This is due to the way that visium data is acquired. The Visium slide is placed on top of the tissue but the H&E image is acquired from below the tissue.\n\n- On top of the spots we know see the hexagonal neighbourhood on top of the regular lattice. \n\n# Univariate Analysis\n\n## Global indicators of spatial association\n\nNow that we have defined both the neighbourhood of a spot and preprocessed the gene expression, we can turn to measures of spatial association. \n\nIn general, in a global association metric we compute for each point $i$ a metric for its neighbourhood $j$. The neighbourhood we quantified before as the regular hexagonal grid and is passed to the functions as a weight matrix $w_{ij}$. The association measure is then a function $f(x_i,x_j)$ and could e.g. quantify spatial correlation\n\n$$\n\\sum_i \\sum_j f(x_i,x_j) w_{ij}\n$$\n\nA very famous measure of global spatial autocorrelation is called Moran's $I$. It assess correlation of a gene with itself given a defined weight matrix $w$ [@moran1950notes]. \n\n::: callout-important\n## Exercise\n\n- Model the variance of the log-transformed expression profiles per gene with `scran::modelGeneVar()` (using the argument `subset.row` will make the fitting faster)\n- Extract the top 200 highly variable genes in this dataset with `scran::getTopHVGs()`\n- Calculate the global Moran's $I$ coefficient with the function `Voyager::runUnivariate()` on these 200 highly variable genes. You can find information and examples on how to run this function by typing `?runUnivariate` in your console\n- Extract the top 3 genes with the highest Moran's $I$ value\n- Plot the expression of these three genes in space using `Voyager::plotSpatialFeature`\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nFirst, we model the variance on a subset of the genes for computational reasons\nThen, we extract the 200 most highly variable genes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats <- scran::modelGeneVar(sfe, subset.row = 1:2000)\nhvg <- scran::getTopHVGs(stats, n = 200)\n```\n:::\n\n\nNext, we calculate global Moran's I for these 200 genes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- runUnivariate(sfe, \n    type=\"moran\", \n    features=hvg, \n    colGraphName=\"visium\")\n```\n:::\n\n\nWe order them and plot the gene expression top 3 genes wiht the `plotSpatialFeature` function from the `Voyager` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nI <- rowData(sfe)$moran_sample01\no <- order(I, decreasing=TRUE)\ntopGenes <- rownames(sfe)[head(o, 3)]\nplotSpatialFeature(sfe, topGenes, ncol=3)\n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-8-1.png){width=672}\n:::\n:::\n\n\n::: \n\n## Local indicators of spatial association\n\nIn the section above, we have computed a global measure of spatial association, meaning that we get one number per field-of-view. This is an average of the local contributions and neglects the potential underlying heterogeneity completely. \n\nTherefore, we will investigate local indicators of spatial association [@anselin1995local]. \n\nIn the case of Moran's $I$ we will now not calculate one measure for the entire field-of-view but rather one metric per location/spot $i$: $I_i$.\n\n::: callout-important\n## Exercise\n\n- Calculate local Moran's $I$ for the top three global Moran's $I$ genes from above using the function `Voyager::runUnivariate()`\n\n- Plot the local Moran's $I$ values in space using `Voyager::plotLocalResult`\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nFirst, we have to calculate the metric on the first most autocorrelated genes. \n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- runUnivariate(sfe,\n                     features = topGenes,\n                     colGraphName = \"visium\",\n                     type = \"localmoran\")\n```\n:::\n\n\nThen, we plot the local Moran's $I$ values in space. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotLocalResult(sfe, \"localmoran\",\n                features =topGenes, ncol = 3,\n                colGeometryName = \"centroids\",\n                divergent = TRUE, diverge_center = 0)\n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-10-1.png){width=672}\n:::\n:::\n\n\n:::\n\n## Discretising regions with Moran's scatterplot\n\nThe continuous local Moran's $I_i$ measurements can be difficult to interpret. A simplification is Moran's scatter plot [@anselin2019moran]. The idea is to compare the Moran's $I$ of the spot $i$ itself with its neighbours $j$. Like this we obtain four options: high $I_i$ next to neighbours that have high $I_j$, high $I_i$ next to neighbours that have low $I_j$ etc. This separates outliers (high-low and low-high) from values within more homogeneous regions (high-high and low-low).\n\n::: callout-important\n## Bonus Exercise\n\n- Calculate Moran's scatterplot with `runUnivariate` on the top three global Moran's $I$ genes from above\n\n- Plot the Moran's scatterplot results in space using `Voyager::plotLocalResult`\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nFirst, we have to calculate the metric on the first three most variable hvgs. \n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- runUnivariate(\n    sfe,\n    features =  topGenes,\n    colGraphName = \"visium\",\n    type = \"moran.plot\"\n  )\n```\n:::\n\n\nWe will show the Moran's scatter plot for the gene `PIGR`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we will show one Moran's scatterplot\nmoranPlot(sfe, topGenes[1], graphName = \"visium\", swap_rownames = \"symbol\") + theme_classic()\n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-12-1.png){width=672}\n:::\n:::\n\n\nThe grey dashed lines indicate the mean expreession of the \"PIGR\" expression in the spots themselves and among their neighbours. According to to these means the spots are categorised into 4 categories, which can be plotted back in space. We notice that there is quite a large fraction of regions that constitute as \"high-high\" for all the genes in the same region.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotLocalResult(\n    sfe,\n    name = \"localmoran\",\n    features = topGenes,\n    attribute = \"mean\",\n    colGeometryName = \"centroids\"\n)\n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-13-1.png){width=672}\n:::\n:::\n\n\n:::\n\n# Multivariate Analysis\n\nAll of the analyses we showed above, were univariate comparison. Moran's $I$ and other association measures have also bivariate and even multivariate variants. \n\n::: callout-important\n## Question\n\n- Which type of biological question do you think would be nicely addessed with e.g. a bivariate spatial association measure? \n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nOne potentially interesting set of questions one could answer with bivariate spatial association measures are ligand-receptor interactions. \n\n::: \n\n::: callout-important\n## Bonus Exercise\n\n- Calculate a bivariate Moran's $I$ for the genes `PIGR` and `CLCA1` using the function `Voyager::runBivariate()`\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfe <- runBivariate(sfe, type = \"localmoran_bv\",\n                    feature1 = \"PIGR\", feature2 = \"CLCA1\",\n                    colGraphName = \"visium\",\n                    nsim = 499)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotLocalResult(sfe, \"localmoran_bv\", \n                features = localResultFeatures(sfe, \"localmoran_bv\"),\n                ncol = 2, divergent = TRUE, diverge_center = 0,\n                colGeometryName = \"centroids\") \n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-15-1.png){width=672}\n:::\n:::\n\n\nWe notice that there is one region showing high bivariate Moran's I. This is also the region where both univariate Moran's I scatterplot values were \"high-high\". The regions which were classified \"high-high\" individually for each gene do not show up here.\n\n::: \n\n# Bonus: Multi-sample Analysis\n\nThis chapter so far showed how to perform lattice-data analysis for one sample. Lattice data analysis is not yet very common in multi-sample analyses. \n\nOne option is to compute a measure of global spatial association giving one numerical value per field-of-view. \n\nFirst we will load 4 slides from the dataset (2 healthy slides and 2 cancerous slides). \n\nDue to conversion issues, this code creates a `SpatialFeatureExperiment` via a `SingleCellExperiment`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspeMult <- loadHDF5SummarizedExperiment(dir=\"data/\", prefix=\"02.3_spe_tmp\")\n\nspeMult$array_row <- speMult$row\nspeMult$array_col <- speMult$col\n\ncolData(speMult)$sample_id |> unique()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Normal_P5 Cancer_P5 Cancer_P1 Normal_P3\nLevels: Cancer_P1 Cancer_P5 Normal_P3 Normal_P5\n```\n\n\n:::\n\n```{.r .cell-code}\nsceMult <- as(speMult, \"SingleCellExperiment\")\ncolData(sceMult) <- colData(sceMult) |> cbind(spatialCoords(speMult))\n```\n:::\n\n\nNext, we will convert the `SingelCellExperiment` to a `SpatialFeatureExperiment`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfeMult <- toSpatialFeatureExperiment(sceMult,\n sample_id = \"sample_id\",\n spatialCoordsNames = c(\"pxl_col_in_fullres\", \"pxl_row_in_fullres\"),\n loadImage = FALSE)\nsfeMult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SpatialFeatureExperiment \ndim: 18045 56120 \nmetadata(0):\nassays(1): counts\nrownames(18045): SAMD11 NOC2L ... MT-ND6 MT-CYB\nrowData names(3): ID Symbol Type\ncolnames(56120): s_016um_00145_00029-1.Normal_P5\n  s_016um_00165_00109-1.Normal_P5 ... s_016um_00122_00096-1.Normal_P3\n  s_016um_00127_00062-1.Normal_P3\ncolData names(7): row col ... array_row array_col\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(0):\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nNormal_P5: \nCancer_P5: \nCancer_P1: \nNormal_P3: \n```\n\n\n:::\n:::\n\n\n## Preprocessing and neighbourhood defintion\n\nWe note that the counts in our `SpatialFeatureExperiment` object are still raw counts therefore we will log normalise them with `scuttle::logNormCounts()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# identify mitochondrial genes\ngn <- rowData(sfeMult)$Symbol\nmt <- grepl(\"^MT-\", gn, ignore.case = TRUE)\ntable(mt)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nmt\nFALSE  TRUE \n18034    11 \n```\n\n\n:::\n\n```{.r .cell-code}\n# remove them\nsfeMult <- sfeMult[!mt, ]\n\n#log-normalise the counts\nsfeMult <- scuttle::logNormCounts(sfeMult)\nsfeMult\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass: SpatialFeatureExperiment \ndim: 18034 56120 \nmetadata(0):\nassays(2): counts logcounts\nrownames(18034): SAMD11 NOC2L ... KDM5D EIF1AY\nrowData names(3): ID Symbol Type\ncolnames(56120): s_016um_00145_00029-1.Normal_P5\n  s_016um_00165_00109-1.Normal_P5 ... s_016um_00122_00096-1.Normal_P3\n  s_016um_00127_00062-1.Normal_P3\ncolData names(8): row col ... array_col sizeFactor\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(1): sample_id\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nNormal_P5: \nCancer_P5: \nCancer_P1: \nNormal_P3: \n```\n\n\n:::\n:::\n\n\nNow, we notice a `logcounts` assay in our object.\n\nNext, we will define a neighbourhood on which we want to compute spatial statistics metrics. For computational reasons we will consider a $k$ nearest neighbourhood around the cells.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallGraphs <- findSpatialNeighbors(sfeMult,\n    method = \"knearneigh\", # wraps the spdep function with the same name\n    k = 5,\n    zero.policy = TRUE,\n    sample_id = \"all\"\n  )\n\ncolGraphs(sfeMult, \"knn5\", sample_id = \"all\") <- allGraphs\n```\n:::\n\n\n::: callout-important\n## Question\n\n- Given you have now a `SpatialFeatureExperiment` object with four samples, how would you compare a global indicator of spatial association across conditions, possibly with multiple samples? As an example, calculate global univariate Moran's $I$ for the gene \"PIGR\".\n\n- an important flag in this question is `sample_id = \"all\"`. For reasons of having isolated cell patches, consider a $k$-NN neighbourhood this time instead of `findVisiumGraph`.\n\n:::\n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nFirst, we need to calculate univariate Moran's $I$ for all samples\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsfeMult <- runUnivariate(sfeMult,\n                     features = \"PIGR\",\n                     colGraphName = \"knn5\",\n                     exprs_values = \"logcounts\",\n                     sample_id = \"all\",\n                     type = \"moran.mc\",\n                     nsim = 200)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- rowData(sfeMult)[\"PIGR\",]\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDataFrame with 1 row and 27 columns\n                  ID      Symbol            Type moran.mc_statistic_Normal_P5\n         <character> <character>        <factor>                    <numeric>\nPIGR ENSG00000162896        PIGR Gene Expression                     0.665933\n     moran.mc_parameter_Normal_P5 moran.mc_p.value_Normal_P5\n                        <numeric>                  <numeric>\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Normal_P5 moran.mc_method_Normal_P5\n                        <character>               <character>\nPIGR                        greater    Monte-Carlo simulati..\n                   moran.mc_res_Normal_P5 moran.mc_statistic_Cancer_P5\n                                   <list>                    <numeric>\nPIGR 0.00364546,0.00024356,0.00120214,...                     0.662601\n     moran.mc_parameter_Cancer_P5 moran.mc_p.value_Cancer_P5\n                        <numeric>                  <numeric>\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Cancer_P5 moran.mc_method_Cancer_P5\n                        <character>               <character>\nPIGR                        greater    Monte-Carlo simulati..\n                      moran.mc_res_Cancer_P5 moran.mc_statistic_Cancer_P1\n                                      <list>                    <numeric>\nPIGR -0.00521515,-0.00276429, 0.01003306,...                     0.839516\n     moran.mc_parameter_Cancer_P1 moran.mc_p.value_Cancer_P1\n                        <numeric>                  <numeric>\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Cancer_P1 moran.mc_method_Cancer_P1\n                        <character>               <character>\nPIGR                        greater    Monte-Carlo simulati..\n                      moran.mc_res_Cancer_P1 moran.mc_statistic_Normal_P3\n                                      <list>                    <numeric>\nPIGR -0.00500185, 0.00928462, 0.00367372,...                     0.554004\n     moran.mc_parameter_Normal_P3 moran.mc_p.value_Normal_P3\n                        <numeric>                  <numeric>\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Normal_P3 moran.mc_method_Normal_P3\n                        <character>               <character>\nPIGR                        greater    Monte-Carlo simulati..\n                      moran.mc_res_Normal_P3\n                                      <list>\nPIGR -0.00188827,-0.00658297, 0.00488671,...\n```\n\n\n:::\n:::\n\n\nIn order to model these measures, we have to convert the data into long format\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long <- res |> as.data.frame() |>\n  tibble::rownames_to_column(\"gene\") |>\n  pivot_longer(\n    cols = starts_with(\"moran.mc_statistic\"),\n    names_to = c(\"measure\", \"sample\"),\n    names_pattern = \"(.*)statistic_(.*)\",\n    values_to = \"morans\"\n  ) |> separate(sample, into = c(\"condition\", \"replicate\"), sep = \"_\") |> \n  select(c( \"gene\", \"condition\",  \"replicate\", \"measure\", \"morans\"))\n\ndf_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 Ã— 5\n  gene  condition replicate measure   morans\n  <chr> <chr>     <chr>     <chr>      <dbl>\n1 PIGR  Normal    P5        moran.mc_  0.666\n2 PIGR  Cancer    P5        moran.mc_  0.663\n3 PIGR  Cancer    P1        moran.mc_  0.840\n4 PIGR  Normal    P3        moran.mc_  0.554\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(df_long$condition, df_long$replicate)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        \n         P1 P3 P5\n  Cancer  1  0  1\n  Normal  0  1  1\n```\n\n\n:::\n:::\n\n\nWe see that we have a nested variance structure in this data. We have two conditions \"Normal\" and \"Cancer\". We note that the patient identifiers are not unique, meaning that we have some samples from the same patient.\n\nIn order to account for this dependence, we have to model the data with a mixed-effects model. One option is the `lme4` package in R.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#convert condition to a factor and relevel to have Normal as comparison group\ndf_long$condition <- as.factor(df_long$condition) |>\n  relevel(ref = \"Normal\")\nmdl <- lmer(morans ~ condition + (1|replicate), data = df_long)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nboundary (singular) fit: see help('isSingular')\n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(mdl)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: morans ~ condition + (1 | replicate)\n   Data: df_long\n\nREML criterion at convergence: -2\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-0.8451 -0.6123  0.0000  0.6123  0.8451 \n\nRandom effects:\n Groups    Name        Variance Std.Dev.\n replicate (Intercept) 0.00000  0.0000  \n Residual              0.01096  0.1047  \nNumber of obs: 4, groups:  replicate, 3\n\nFixed effects:\n                Estimate Std. Error      df t value Pr(>|t|)  \n(Intercept)      0.60997    0.07402 2.00000   8.241   0.0144 *\nconditionCancer  0.14109    0.10467 2.00000   1.348   0.3101  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr)\nconditnCncr -0.707\noptimizer (nloptwrap) convergence code: 0 (OK)\nboundary (singular) fit: see help('isSingular')\n```\n\n\n:::\n:::\n\n\nWe note that in this example there is no difference in the global Moran's $I$ value for the gene \"PIGR\". This not surprising since a model with 3 independent samples is strongly under-powered.\n\nAn important step in interpreting a statistical model is looking at some model diagnostics. We will plot the qq plot of this mixed effects model. We note that the four samples follow the theoretical line well. But we notice again, that having only four samples is a great limitation of this dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqqnorm(resid(mdl), pch = 16)\nqqline(resid(mdl))\n```\n\n::: {.cell-output-display}\n![](day2-1_spatial_stats_files/figure-html/day2-1-spatial-stats-25-1.png){width=672}\n:::\n:::\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}