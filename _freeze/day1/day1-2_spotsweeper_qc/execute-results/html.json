{
  "hash": "f76d3efa4eb89262e31d52d38c9f8361",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Exercise 2\"\nformat: html\neditor: source\neditor_options: \n  chunk_output_type: console\n---\n\n## Quality Control using `SpotSweeper`\n\nIn this second exercise, we will focus on the critical step of quality control (QC) for spatial transcriptomics data. Using the `SpotSweeper` package, we will learn how to identify and handle low-quality spots and spatial artifacts, which is essential for ensuring the reliability of downstream analyses. We will calculate various QC metrics, detect local outliers, and visualize the results to gain a comprehensive understanding of data quality.\n\n## Learning Objectives\n\nBy the end of this exercise, you will be able to:\n\n- Load a `SpatialExperiment` object from a `.qs` file.\n- Calculate per-spot QC metrics.\n- Identify local outliers based on various QC metrics.\n- Detect spatial artifacts using `SpotSweeper`.\n- Visualize QC metrics and detected artifacts.\n\n# Libraries\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(SpatialExperiment)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: SingleCellExperiment\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: SummarizedExperiment\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: MatrixGenerics\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: matrixStats\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'MatrixGenerics'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:matrixStats':\n\n    colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,\n    colCounts, colCummaxs, colCummins, colCumprods, colCumsums,\n    colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,\n    colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,\n    colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,\n    colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,\n    colWeightedMeans, colWeightedMedians, colWeightedSds,\n    colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,\n    rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,\n    rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,\n    rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,\n    rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,\n    rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,\n    rowWeightedMads, rowWeightedMeans, rowWeightedMedians,\n    rowWeightedSds, rowWeightedVars\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: GenomicRanges\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: stats4\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: BiocGenerics\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: generics\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'generics'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    as.difftime, as.factor, as.ordered, intersect, is.element, setdiff,\n    setequal, union\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'BiocGenerics'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:stats':\n\n    IQR, mad, sd, var, xtabs\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    anyDuplicated, aperm, append, as.data.frame, basename, cbind,\n    colnames, dirname, do.call, duplicated, eval, evalq, Filter, Find,\n    get, grep, grepl, is.unsorted, lapply, Map, mapply, match, mget,\n    order, paste, pmax, pmax.int, pmin, pmin.int, Position, rank,\n    rbind, Reduce, rownames, sapply, saveRDS, table, tapply, unique,\n    unsplit, which.max, which.min\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: S4Vectors\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'S4Vectors'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:utils':\n\n    findMatches\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    expand.grid, I, unname\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: IRanges\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: GenomeInfoDb\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Biobase\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWelcome to Bioconductor\n\n    Vignettes contain introductory material; view with\n    'browseVignettes()'. To cite Bioconductor, see\n    'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'Biobase'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:MatrixGenerics':\n\n    rowMedians\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:matrixStats':\n\n    anyMissing, rowMedians\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(qs2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nqs2 0.1.5\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(SpotSweeper)\nlibrary(scuttle)\nlibrary(ggplot2)\nlibrary(escheR) # For spatial plotting\nlibrary(HDF5Array)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: SparseArray\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: Matrix\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'Matrix'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:S4Vectors':\n\n    expand\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: S4Arrays\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: abind\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'S4Arrays'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:abind':\n\n    abind\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:base':\n\n    rowsum\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: DelayedArray\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'DelayedArray'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:base':\n\n    apply, scale, sweep\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: h5mread\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required package: rhdf5\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'h5mread'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following object is masked from 'package:rhdf5':\n\n    h5ls\n```\n\n\n:::\n:::\n\n\n# Data Object\n\nIn this section, we will load our `SpatialExperiment` object, which has been saved as a `.qs2` file, and prepare it for quality control analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load the SpatialExperiment object from the .qs2 file.\n# This object contains the processed spatial transcriptomics data.\nspe <- qs_read(\"results/01_spe.qs2\", nthreads = 1)\n\n# Change row names from gene IDs to gene symbols for easier interpretation.\n# This assumes 'Symbol' is a column in the rowData of the SpatialExperiment object.\nrownames(spe) <- rowData(spe)$Symbol\n\n# Identify mitochondrial transcripts. These are often used as a QC metric.\n# Genes starting with \"MT-\" are typically mitochondrial.\nis.mito <- rownames(spe)[grepl(\"^MT-\", rownames(spe))]\n\n# Calculate per-spot (per-cell) QC metrics using scuttle's addPerCellQCMetrics function.\n# This adds metrics like sum (total counts), detected (number of detected genes),\n# and mitochondrial gene percentage to the colData of the SpatialExperiment object.\nspe <- scuttle::addPerCellQCMetrics(spe, subsets = list(Mito = is.mito))\n\n# Display the column names of the colData to see the newly added QC metrics.\ncolnames(colData(spe))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"barcode\"               \"in_tissue\"             \"array_row\"            \n [4] \"array_col\"             \"bin_size\"              \"sample_id\"            \n [7] \"sum\"                   \"detected\"              \"subsets_Mito_sum\"     \n[10] \"subsets_Mito_detected\" \"subsets_Mito_percent\"  \"total\"                \n```\n\n\n:::\n:::\n\n\n# Subsetting for Demonstration\n\nFor the purpose of this tutorial, and to reduce computation time, we will subset the `SpatialExperiment` object to a smaller number of genes and spots. In a real analysis, you would typically work with the full dataset or apply more sophisticated filtering criteria.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Subset to a smaller number of genes (e.g., top 1000 genes by variance or a random subset).\n# For simplicity, let's take a random subset of 1000 genes.\nset.seed(123) # for reproducibility\nnum_genes_to_keep <- 1000\nif (nrow(spe) > num_genes_to_keep) {\n  gene_indices <- sample(seq_len(nrow(spe)), num_genes_to_keep)\n  spe_subset <- spe[gene_indices, ]\n} else {\n  spe_subset <- spe\n}\n\n# Subset to a smaller number of spots (e.g., a random subset of 5000 spots).\nnum_spots_to_keep <- 5000\nif (ncol(spe_subset) > num_spots_to_keep) {\n  spot_indices <- sample(seq_len(ncol(spe_subset)), num_spots_to_keep)\n  spe_subset <- spe_subset[, spot_indices]\n} else {\n  spe_subset <- spe_subset\n}\n\nspe <- spe_subset\n\n# Display the dimensions of the subsetted object to confirm reduction.\ndim(spe)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1000 5000\n```\n\n\n:::\n:::\n\n\n## Question: Impact of Subsetting\n\n**What are the potential implications of subsetting the data (both genes and spots) for QC analysis in a real-world scenario?**\n\n:::{.callout-tip collapse=\"true\"}\n### Answer\n\nSubsetting the data can significantly speed up computations, which is beneficial for tutorials and initial exploration. However, in a real-world scenario, it has several implications:\n\n-   **Loss of Information:** Subsetting genes might remove important genes that could be relevant for certain QC metrics or biological insights. Subsetting spots might miss localized artifacts or rare cell populations.\n-   **Altered Statistics:** Metrics like `localOutliers` and `findArtifacts` rely on neighborhood information. Subsetting spots can change the definition of neighborhoods and thus alter the results of these analyses.\n-   **Representativeness:** A small subset might not be representative of the entire dataset, potentially leading to biased conclusions about data quality.\n\nTherefore, while useful for quick demonstrations, full QC should ideally be performed on the complete dataset.\n:::\n\n# Local Outlier Detection\n\nHere, we identify local outliers based on common QC metrics such as library size, number of detected genes, and mitochondrial percentage. `localOutliers` from `SpotSweeper` helps in identifying spots that deviate significantly from their local neighborhood.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify local outliers based on library size (\"sum\" of counts).\n# Spots with unusually low library size compared to their neighbors will be flagged.\nspe <- localOutliers(spe,\n  metric = \"sum\",\n  direction = \"lower\",\n  log = TRUE,\n  workers = parallel::detectCores() - 1\n)\n\n# Identify local outliers based on the number of unique genes detected (\"detected\").\n# Spots with an unusually low number of detected genes will be flagged.\nspe <- localOutliers(spe,\n  metric = \"detected\",\n  direction = \"lower\",\n  log = TRUE,\n  workers = parallel::detectCores() - 1\n)\n\n# Identify local outliers based on the mitochondrial gene percentage.\n# Spots with an unusually high mitochondrial percentage will be flagged.\nspe <- localOutliers(spe,\n  metric = \"subsets_Mito_percent\",\n  direction = \"higher\",\n  log = FALSE,\n  workers = parallel::detectCores() - 1\n)\n\n# Combine all individual outlier flags into a single \"local_outliers\" column.\n# A spot is considered a local outlier if it's flagged by any of the above metrics.\nspe$local_outliers <- as.logical(spe$sum_outliers) |\n  as.logical(spe$detected_outliers) |\n  as.logical(spe$subsets_Mito_percent_outliers)\n```\n:::\n\n\n## Question 1\n\n**How many spots were identified as local outliers based on the combined criteria?**\n\n:::{.callout-tip collapse=\"true\"}\n### Answer\n\n```r\n# Count the number of spots flagged as local outliers.\ntable(spe$local_outliers)\n```\n:::\n\n## Spatial Artifact Detection with `SpotSweeper`\n\n`SpotSweeper` is designed to detect spatial artifacts that might not be captured by simple local outlier detection. This is particularly useful for identifying regions with systematic issues.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# not working anymore\nspe <- findArtifacts(spe,\n  mito_percent = \"subsets_Mito_percent\", # Using the metric calculated by scuttle\n  mito_sum = \"subsets_Mito_sum\", # Using the metric calculated by scuttle\n  name = \"artifact\"\n)\n\n# Check that \"artifact\" is now a column in colData, indicating detected artifacts.\ncolnames(colData(spe))\n```\n:::\n\n\n## Question 2\n\n**What is the difference between `localOutliers` and `findArtifacts`? When would you use one over the other?**\n\n:::{.callout-tip collapse=\"true\"}\n### Answer\n\n`localOutliers` identifies individual spots that deviate significantly from their immediate neighbors based on a single metric (e.g., unusually low library size). It's good for detecting isolated problematic spots.\n\n`findArtifacts` from `SpotSweeper` is designed to detect larger, spatially coherent regions of problematic spots (artifacts) by considering multiple metrics and their spatial patterns. It's more suitable for identifying systematic issues across a larger area of the tissue.\n\nYou would use `localOutliers` for general per-spot QC and `findArtifacts` when you suspect or observe larger, structured regions of poor quality that might indicate experimental issues or tissue damage.\n:::\n\n# Visualization of QC Results\n\nVisualizing the QC metrics and detected artifacts is crucial for understanding the quality of your spatial transcriptomics data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot the spatial distribution of local outliers.\n# Spots flagged as local outliers will be highlighted.\nplotQCmetrics(spe,\n  metric = \"sum_log\", outliers = \"local_outliers\", point_size = 1.1,\n  stroke = 0.75\n) +\n  ggtitle(\"All Local Outliers\")\n```\n\n::: {.cell-output-display}\n![](day1-2_spotsweeper_qc_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n## Question 3\n\n**Plot the spatial distribution of the `artifact` column identified by `SpotSweeper`.**\n\n:::{.callout-tip collapse=\"true\"}\n### Answer\n\n```r\n# Plot the spatial distribution of the detected artifacts.\nplotQCmetrics(spe,\n    metric = \"subsets_Mito_percent\", # You can choose any relevant metric to display\n    outliers = \"artifact\", \n    point_size = 1.1\n) +\n    ggtitle(\"Detected Spatial Artifacts\")\n```\n:::\n\n:::{.callout-important}\n**Key Takeaways:**\n\n-   `scuttle::addPerCellQCMetrics` provides essential per-spot QC metrics.\n-   `SpotSweeper::localOutliers` helps identify individual problematic spots.\n-   `SpotSweeper::findArtifacts` is powerful for detecting spatially coherent regions of poor quality.\n-   Visualizing QC results is critical for data interpretation and downstream analysis decisions.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}