---
title: "Exercise 1"
editor: source
editor_options: 
  chunk_output_type: inline
bibliography: ../references.bib
---

## Learning objectives

- Learn the basic principles of exploratory spatial statistics
- Compute and visualise local and global measures of spatial autocorrelation
- Compare spatial statistics measures across samples using linear mixed models
- This chapter is based on the `OSTA` online book chapter on spatial statistics and uses heavily the `Voyager` spatial statistics library [@moses2023voyager]

## Libraries
```{r day2-1-spatial-stats-1 }
#| message: false
#| warning: false
#| output: false

library("SpatialExperiment")
library("ggplot2")
library("Voyager")
library("HDF5Array")
library("tidyr")
library("dplyr")
library("lme4")
library("lmerTest")
set.seed(1234)
```

## Load data

```{r day2-1-spatial-stats-2 }
# Load the SpatialExperiment objectq
spe <- loadHDF5SummarizedExperiment(dir="results/day1", prefix="01.1_spe")
```

In order to use the big spatial statistics library `sf` we convert the `SpatialExperiment` object into a `SpatialFeatureExperiment` object [@Moses2025.02.24.640007]. In addition to the `SpatialExperiment` object it contains simple feature categories such as `Geometries` and `Graphs`. In this 10x Visium Dataset the `Geometries` stored are the coordinates of the spots

```{r day2-1-spatial-stats-3 }
sfe <- toSpatialFeatureExperiment(spe)
sfe
```

## Data modalities of spatial statistics

In spatial transcriptomics we differentiate between imaging-based and sequencing-based technologies which give rise to very different _data modalities_ [@rao2021exploring].  

![Data Modalities in Spatial Transcriptomics [@emons2025harnessing]](https://oup.silverchair-cdn.com/oup/backfile/Content_public/Journal/nar/53/17/10.1093_nar_gkaf870/1/gkaf870fig1.jpeg?Expires=1766403187&Signature=WxVqrLv3B2ktSO5UWsRogBTtrwQeC3Ol-gM090kNJc8hAakLbV1v~BmiBJ5ae-810EciaTYjbNSvPwAGSzaWQXbh9qSOf4jjkNwJsMp2JEI77MoADpxGWvO17H4PUrzfaRlDZK82fc~Ik2GchhlLaKJvQWAMvIKEAdSwrB74D~sbAKqTL1bngu3xL-Ta4x3254JJJbSdAeHbmXH1e8jpeTTFri63iYHI3yUkhJAYhltRKwlfhCkwO2F7Hj1EcwPrTKJK~oFe2igeODcCkpnpvRqZDgAI3ImcF52nGksXGzqXQTO72RPolepCA1cVdGCcQ8K-VUjTGnsB8Ide89-gJw__&Key-Pair-Id=APKAIE5G5CRDK6RD3PGA)

Our dataset was acquired using 10x Visium HD. The data modality of this technology is best described by a _regular lattice_. This means that the observations are taken at regularly spaced intervals. This is very different to imaging-based approaches where observations are due to a stochastic data generating process, which is related to some underlying biological mechanism. 

With spots of 2um^2, Visium HD can provide subcellular resolution. We can segment cells from this regular lattice of pixels and approximate the cells by their centroid. This in turn can be described as an _irregular lattice_ of the cell types in space or even be analysed as a point process of the cell centroid locations. 

In what follows we will focus on analysing the regular lattice of the pixel measurements with techniques from lattice data analysis.

## Preprocessing and neighbourhood defintion

We note that the counts in our `SpatialFeatureExperiment` object are still raw counts therefore we will log normalise them with `scuttle::logNormCounts()`

```{r day2-1-spatial-stats-4 }
# identify mitochondrial genes
gn <- rowData(sfe)$Symbol
mt <- grepl("^MT-", gn, ignore.case = TRUE)
table(mt)
# remove them
sfe <- sfe[!mt, ]

#log-normalise the counts
sfe <- scuttle::logNormCounts(sfe)
sfe
```

Now, we notice a `logcounts` assay in our object.

Next, we will define a neighbourhood on which we want to compute spatial statistics metrics. In 10x Visium it is very natural to consider the direct neigbours of hexagonal visium lattice. We do this with the function `Voyager::findVisiumGraph()`. 

```{r day2-1-spatial-stats-5 }
colGraph(sfe, "visium") <- findVisiumGraph(sfe)
colGraph(sfe, "binary") <- findVisiumGraph(sfe, style = "B")

plotColGraph(sfe,
  colGraphName = "visium"
) + theme_void()
```

We notice two things:

- The $y$-coordinate is flipped compared to the image. This is due to the way that visium data is acquired. The Visium slide is placed on top of the tissue but the H&E image is acquired from below the tissue.

- On top of the spots we know see the hexagonal neighbourhood on top of the regular lattice. 

# Univariate Analysis

## Global indicators of spatial association

Now that we have defined both the neighbourhood of a spot and preprocessed the gene expression, we can turn to measures of spatial association. 

In general, in a global association metric we compute for each point $i$ a metric for its neighbourhood $j$. The neighbourhood we quantified before as the regular hexagonal grid and is passed to the functions as a weight matrix $w_{ij}$. The association measure is then a function $f(x_i,x_j)$ and could e.g. quantify spatial correlation

$$
\sum_i \sum_j f(x_i,x_j) w_{ij}
$$

A very famous measure of global spatial autocorrelation is called Moran's $I$. It assess correlation of a gene with itself given a defined weight matrix $w$ [@moran1950notes]. 

::: callout-important
## Exercise

- Model the variance of the log-transformed expression profiles per gene with `scran::modelGeneVar()` (using the argument `subset.row` will make the fitting faster)
- Extract the top 200 highly variable genes in this dataset with `scran::getTopHVGs()`
- Calculate the global Moran's $I$ coefficient with the function `Voyager::runUnivariate()` on these 200 highly variable genes. You can find information and examples on how to run this function by typing `?runUnivariate` in your console
- Extract the top 3 genes with the highest Moran's $I$ value
- Plot the expression of these three genes in space using `Voyager::plotSpatialFeature`

:::

::: {.callout-tip collapse="true"}
## Answer

First, we model the variance on a subset of the genes for computational reasons
Then, we extract the 200 most highly variable genes

```{r day2-1-spatial-stats-6 }
stats <- scran::modelGeneVar(sfe, subset.row = 1:2000)
hvg <- scran::getTopHVGs(stats, n = 200)
```

Next, we calculate global Moran's I for these 200 genes

```{r day2-1-spatial-stats-7 }
sfe <- runUnivariate(sfe, 
    type="moran", 
    features=hvg, 
    colGraphName="visium")
```

We order them and plot the gene expression top 3 genes wiht the `plotSpatialFeature` function from the `Voyager` package.

```{r day2-1-spatial-stats-8 }
I <- rowData(sfe)$moran_sample01
o <- order(I, decreasing=TRUE)
topGenes <- rownames(sfe)[head(o, 3)]
plotSpatialFeature(sfe, topGenes, ncol=3)
```

::: 

## Local indicators of spatial association

In the section above, we have computed a global measure of spatial association, meaning that we get one number per field-of-view. This is an average of the local contributions and neglects the potential underlying heterogeneity completely. 

Therefore, we will investigate local indicators of spatial association [@anselin1995local]. 

In the case of Moran's $I$ we will now not calculate one measure for the entire field-of-view but rather one metric per location/spot $i$: $I_i$.

::: callout-important
## Exercise

- Calculate local Moran's $I$ for the top three global Moran's $I$ genes from above using the function `Voyager::runUnivariate()`

- Plot the local Moran's $I$ values in space using `Voyager::plotLocalResult`

:::

::: {.callout-tip collapse="true"}
## Answer

First, we have to calculate the metric on the first most autocorrelated genes. 
```{r day2-1-spatial-stats-9 }
sfe <- runUnivariate(sfe,
                     features = topGenes,
                     colGraphName = "visium",
                     type = "localmoran")
```

Then, we plot the local Moran's $I$ values in space. 

```{r day2-1-spatial-stats-10 }
plotLocalResult(sfe, "localmoran",
                features =topGenes, ncol = 3,
                colGeometryName = "centroids",
                divergent = TRUE, diverge_center = 0)
```

:::

## Discretising regions with Moran's scatterplot

The continuous local Moran's $I_i$ measurements can be difficult to interpret. A simplification is Moran's scatter plot [@anselin2019moran]. The idea is to compare the Moran's $I$ of the spot $i$ itself with its neighbours $j$. Like this we obtain four options: high $I_i$ next to neighbours that have high $I_j$, high $I_i$ next to neighbours that have low $I_j$ etc. This separates outliers (high-low and low-high) from values within more homogeneous regions (high-high and low-low).

::: callout-important
## Bonus Exercise

- Calculate Moran's scatterplot with `runUnivariate` on the top three global Moran's $I$ genes from above

- Plot the Moran's scatterplot results in space using `Voyager::plotLocalResult`

:::

::: {.callout-tip collapse="true"}
## Answer

First, we have to calculate the metric on the first three most variable hvgs. 
```{r day2-1-spatial-stats-11 }
sfe <- runUnivariate(
    sfe,
    features =  topGenes,
    colGraphName = "visium",
    type = "moran.plot"
  )
```

We will show the Moran's scatter plot for the gene `PIGR`.

```{r day2-1-spatial-stats-12 }
# we will show one Moran's scatterplot
moranPlot(sfe, topGenes[1], graphName = "visium", swap_rownames = "symbol") + theme_classic()
```

The grey dashed lines indicate the mean expreession of the "PIGR" expression in the spots themselves and among their neighbours. According to to these means the spots are categorised into 4 categories, which can be plotted back in space. We notice that there is quite a large fraction of regions that constitute as "high-high" for all the genes in the same region.

```{r day2-1-spatial-stats-13 }
plotLocalResult(
    sfe,
    name = "localmoran",
    features = topGenes,
    attribute = "mean",
    colGeometryName = "centroids"
)
```

:::

# Multivariate Analysis

All of the analyses we showed above, were univariate comparison. Moran's $I$ and other association measures have also bivariate and even multivariate variants. 

::: callout-important
## Question

- Which type of biological question do you think would be nicely addessed with e.g. a bivariate spatial association measure? 

:::

::: {.callout-tip collapse="true"}
## Answer

One potentially interesting set of questions one could answer with bivariate spatial association measures are ligand-receptor interactions. 

::: 

::: callout-important
## Bonus Exercise

- Calculate a bivariate Moran's $I$ for the genes `PIGR` and `CLCA1` using the function `Voyager::runBivariate()`

:::

::: {.callout-tip collapse="true"}
## Answer

```{r day2-1-spatial-stats-14 }
sfe <- runBivariate(sfe, type = "localmoran_bv",
                    feature1 = "PIGR", feature2 = "CLCA1",
                    colGraphName = "visium",
                    nsim = 499)
```

```{r day2-1-spatial-stats-15 }
plotLocalResult(sfe, "localmoran_bv", 
                features = localResultFeatures(sfe, "localmoran_bv"),
                ncol = 2, divergent = TRUE, diverge_center = 0,
                colGeometryName = "centroids") 
```

We notice that there is one region showing high bivariate Moran's I. This is also the region where both univariate Moran's I scatterplot values were "high-high". The regions which were classified "high-high" individually for each gene do not show up here.

::: 

# Bonus: Multi-sample Analysis

This chapter so far showed how to perform lattice-data analysis for one sample. Lattice data analysis is not yet very common in multi-sample analyses. 

One option is to compute a measure of global spatial association giving one numerical value per field-of-view. 

First we will load 4 slides from the dataset (2 healthy slides and 2 cancerous slides). 

Due to conversion issues, this code creates a `SpatialFeatureExperiment` via a `SingleCellExperiment`

```{r day2-1-spatial-stats-16 }
speMult <- loadHDF5SummarizedExperiment(dir="data/", prefix="02.3_spe_tmp")

speMult$array_row <- speMult$row
speMult$array_col <- speMult$col

colData(speMult)$sample_id |> unique()

sceMult <- as(speMult, "SingleCellExperiment")
colData(sceMult) <- colData(sceMult) |> cbind(spatialCoords(speMult))

```

Next, we will convert the `SingelCellExperiment` to a `SpatialFeatureExperiment`. 

```{r day2-1-spatial-stats-17 }
sfeMult <- toSpatialFeatureExperiment(sceMult,
 sample_id = "sample_id",
 spatialCoordsNames = c("pxl_col_in_fullres", "pxl_row_in_fullres"),
 loadImage = FALSE)
sfeMult
```

## Preprocessing and neighbourhood defintion

We note that the counts in our `SpatialFeatureExperiment` object are still raw counts therefore we will log normalise them with `scuttle::logNormCounts()`

```{r day2-1-spatial-stats-18 }
# identify mitochondrial genes
gn <- rowData(sfeMult)$Symbol
mt <- grepl("^MT-", gn, ignore.case = TRUE)
table(mt)
# remove them
sfeMult <- sfeMult[!mt, ]

#log-normalise the counts
sfeMult <- scuttle::logNormCounts(sfeMult)
sfeMult
```

Now, we notice a `logcounts` assay in our object.

Next, we will define a neighbourhood on which we want to compute spatial statistics metrics. For computational reasons we will consider a $k$ nearest neighbourhood around the cells.

```{r day2-1-spatial-stats-19 }
allGraphs <- findSpatialNeighbors(sfeMult,
    method = "knearneigh", # wraps the spdep function with the same name
    k = 5,
    zero.policy = TRUE,
    sample_id = "all"
  )

colGraphs(sfeMult, "knn5", sample_id = "all") <- allGraphs
```

::: callout-important
## Question

- Given you have now a `SpatialFeatureExperiment` object with four samples, how would you compare a global indicator of spatial association across conditions, possibly with multiple samples? As an example, calculate global univariate Moran's $I$ for the gene "PIGR".

- an important flag in this question is `sample_id = "all"`. For reasons of having isolated cell patches, consider a $k$-NN neighbourhood this time instead of `findVisiumGraph`.

:::

::: {.callout-tip collapse="true"}
## Answer

First, we need to calculate univariate Moran's $I$ for all samples

```{r day2-1-spatial-stats-20 }
sfeMult <- runUnivariate(sfeMult,
                     features = "PIGR",
                     colGraphName = "knn5",
                     exprs_values = "logcounts",
                     sample_id = "all",
                     type = "moran.mc",
                     nsim = 200)
```

```{r day2-1-spatial-stats-21 }
res <- rowData(sfeMult)["PIGR",]
res
```

In order to model these measures, we have to convert the data into long format

```{r day2-1-spatial-stats-22 }
df_long <- res |> as.data.frame() |>
  tibble::rownames_to_column("gene") |>
  pivot_longer(
    cols = starts_with("moran.mc_statistic"),
    names_to = c("measure", "sample"),
    names_pattern = "(.*)statistic_(.*)",
    values_to = "morans"
  ) |> separate(sample, into = c("condition", "replicate"), sep = "_") |> 
  select(c( "gene", "condition",  "replicate", "measure", "morans"))

df_long
```

```{r day2-1-spatial-stats-23 }
table(df_long$condition, df_long$replicate)
```

We see that we have a nested variance structure in this data. We have two conditions "Normal" and "Cancer". We note that the patient identifiers are not unique, meaning that we have some samples from the same patient.

In order to account for this dependence, we have to model the data with a mixed-effects model. One option is the `lme4` package in R.

```{r day2-1-spatial-stats-24 }
#convert condition to a factor and relevel to have Normal as comparison group
df_long$condition <- as.factor(df_long$condition) |>
  relevel(ref = "Normal")
mdl <- lmer(morans ~ condition + (1|replicate), data = df_long)

summary(mdl)
```

We note that in this example there is no difference in the global Moran's $I$ value for the gene "PIGR". This not surprising since a model with 3 independent samples is strongly under-powered.

An important step in interpreting a statistical model is looking at some model diagnostics. We will plot the qq plot of this mixed effects model. We note that the four samples follow the theoretical line well. But we notice again, that having only four samples is a great limitation of this dataset.

```{r day2-1-spatial-stats-25 }
qqnorm(resid(mdl), pch = 16)
qqline(resid(mdl))
```

:::
