[
  {
    "objectID": "qmd/reference_guide.html",
    "href": "qmd/reference_guide.html",
    "title": "Epigenetic Analysis Reference Guide",
    "section": "",
    "text": "This document provides comprehensive reference tables for interpreting chromatin accessibility (ATAC-seq), histone modifications, RNA expression, and DNA methylation patterns in epigenetic analysis. Each table represents different combinations of assays and their biological interpretations.\n\n\n\nATAC-seq: Assay for Transposase-Accessible Chromatin using sequencing\nH3K4me1: Histone H3 lysine 4 monomethylation (enhancer mark)\nH3K4me3: Histone H3 lysine 4 trimethylation (active promoter mark)\nH3K27ac: Histone H3 lysine 27 acetylation (active enhancer/promoter mark)\nH3K27me3: Histone H3 lysine 27 trimethylation (Polycomb repressive mark)\nRNA-seq: RNA sequencing (gene expression)\nDNAme: DNA methylation (CpG methylation)\nTSS: Transcription Start Site\n\n\n\n\n\n↑: Increased signal/activity\n↓: Decreased signal/activity\n∼: Low level or no significant change\nN/A: Not applicable\n-: No change or not detected"
  },
  {
    "objectID": "qmd/reference_guide.html#key-abbreviations",
    "href": "qmd/reference_guide.html#key-abbreviations",
    "title": "Epigenetic Analysis Reference Guide",
    "section": "",
    "text": "ATAC-seq: Assay for Transposase-Accessible Chromatin using sequencing\nH3K4me1: Histone H3 lysine 4 monomethylation (enhancer mark)\nH3K4me3: Histone H3 lysine 4 trimethylation (active promoter mark)\nH3K27ac: Histone H3 lysine 27 acetylation (active enhancer/promoter mark)\nH3K27me3: Histone H3 lysine 27 trimethylation (Polycomb repressive mark)\nRNA-seq: RNA sequencing (gene expression)\nDNAme: DNA methylation (CpG methylation)\nTSS: Transcription Start Site"
  },
  {
    "objectID": "qmd/reference_guide.html#legend",
    "href": "qmd/reference_guide.html#legend",
    "title": "Epigenetic Analysis Reference Guide",
    "section": "",
    "text": "↑: Increased signal/activity\n↓: Decreased signal/activity\n∼: Low level or no significant change\nN/A: Not applicable\n-: No change or not detected"
  },
  {
    "objectID": "qmd/course_schedule.html",
    "href": "qmd/course_schedule.html",
    "title": "Course schedule",
    "section": "",
    "text": "Note\n\n\n\nApart from the starting time the time schedule is indicative. Because we can not plan a course by the minute, in practice the time points will deviate."
  },
  {
    "objectID": "qmd/course_schedule.html#day-1",
    "href": "qmd/course_schedule.html#day-1",
    "title": "Course schedule",
    "section": "Day 1",
    "text": "Day 1\n\n\n\n\n\n\n\n\n\n\n\n\nblock\nstart\nend\ntopic\ninstructor\npresentation\nexercise\n\n\n\n\nintroduction\n9:15\n9:45\nintroduction to the course\n\n\n\n\n\nblock 1\n9:45\n10:30\nintroduction to spatial omics\n\n\n\n\n\nbreak\n10:30\n10:45\n\n\n\n\n\n\nblock 2\n10:45\n12:30\nData structure + quality control + normalization and scaling\n\n\n\n\n\nbreak\n12:30\n13:30\n\n\n\n\n\n\nblock 3\n1:30\n3:00\nExercises quality control\n\n\n\n\n\nbreak\n3:00\n3:15\n\n\n\n\n\n\nblock 4\n3:15\n5:15\nFeature selection, dimensionality reduction and clustering"
  },
  {
    "objectID": "qmd/course_schedule.html#day-2",
    "href": "qmd/course_schedule.html#day-2",
    "title": "Course schedule",
    "section": "Day 2",
    "text": "Day 2\n\n\n\n\n\n\n\n\n\n\n\n\nblock\nstart\nend\ntopic\ninstructor\npresentation\nexercise\n\n\n\n\nblock 1\n9:15\n10:30\nSpatial statistics\nMartin Emonts\n\n\n\n\nbreak\n10:30\n10:45\n\n\n\n\n\n\nblock 2\n10:45\n12:30\nDESpace\nPeiying Cai\n\n\n\n\nbreak\n12:30\n13:30\n\n\n\n\n\n\nblock 3\n1:30\n3:00\nMultiple samples DESpace, differential colocalization\n\n\n\n\n\nbreak\n3:00\n3:15\n\n\n\n\n\n\nblock 4\n3:15\n5:15\nDeconvolution"
  },
  {
    "objectID": "index.html#license-copyright",
    "href": "index.html#license-copyright",
    "title": "Introduction to Sequencing-based Spatial Transcriptomics Data Analysis",
    "section": "License & copyright",
    "text": "License & copyright\nLicense: CC BY 4.0\nCopyright: SIB Swiss Institute of Bioinformatics"
  },
  {
    "objectID": "index.html#learning-outcomes",
    "href": "index.html#learning-outcomes",
    "title": "Introduction to Sequencing-based Spatial Transcriptomics Data Analysis",
    "section": "Learning outcomes",
    "text": "Learning outcomes\n\nGeneral learning outcomes\nAt the end of the course, the participants are expected to:\n\nExplain the principles and describe applications of sequencing-based spatially-resolved transcriptomics (SRT)\nDefine the differences between sequencing-based SRT methods and imaging-based SRT methods.\nIdentify potential pitfalls and limitations of sequencing-based SRT experiments and analysis workflows.\nAssess and interpret raw sequencing outputs and spatial metadata files, understanding their structure and relevance for downstream analyses.\nDefine important aspects of quality control, feature selection, dimensionality reduction and differentail gene expression to SRT data and apply those.\nClarify various spatial statistics and their application to biological questions.\nUse frequently-used methods to analyze multi-sample SRT experiments.\n\n\n\nLearning outcomes explained\nTo reach the general learning outcomes above, we have set a number of smaller learning outcomes. Each chapter starts with these smaller learning outcomes. Use these at the start of a chapter to get an idea what you will learn. Use them also at the end of a chapter to evaluate whether you have learned what you were expected to learn."
  },
  {
    "objectID": "index.html#learning-experiences",
    "href": "index.html#learning-experiences",
    "title": "Introduction to Sequencing-based Spatial Transcriptomics Data Analysis",
    "section": "Learning experiences",
    "text": "Learning experiences\nTo reach the learning outcomes we will use lectures, exercises, polls and group work. During exercises, you are free to discuss with other participants. During lectures, focus on the lecture only.\n\nExercises\nEach block has practical work involved. Some more than others. The practicals are subdivided into chapters, and we’ll have a (short) discussion after each chapter. All answers to the practicals are incorporated, but they are hidden. Do the exercise first by yourself, before checking out the answer. If your answer is different from the answer in the practicals, try to figure out why they are different."
  },
  {
    "objectID": "day2/day2-2_svg_feature_set_signatures.html",
    "href": "day2/day2-2_svg_feature_set_signatures.html",
    "title": "Exercise 2",
    "section": "",
    "text": "In this practical exercise, we focus on spatially structured gene expression, pathway-level signatures. We will calculate SVGs using two families of methods, compare SVGs with HVGs, understand how spatial information influences downstream analysis, and quantify pathway activities using gene-set scoring."
  },
  {
    "objectID": "day2/day2-2_svg_feature_set_signatures.html#spatial-variable-genes-svgs-and-feature-set-signatures",
    "href": "day2/day2-2_svg_feature_set_signatures.html#spatial-variable-genes-svgs-and-feature-set-signatures",
    "title": "Exercise 2",
    "section": "",
    "text": "In this practical exercise, we focus on spatially structured gene expression, pathway-level signatures. We will calculate SVGs using two families of methods, compare SVGs with HVGs, understand how spatial information influences downstream analysis, and quantify pathway activities using gene-set scoring."
  },
  {
    "objectID": "day2/day2-2_svg_feature_set_signatures.html#learning-objectives",
    "href": "day2/day2-2_svg_feature_set_signatures.html#learning-objectives",
    "title": "Exercise 2",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this exercise, you will be able to:\n\nIdentify SVGs with two types of SVGs\nCompare SVGs with HVGs\nScore cells/spots with gene-set signatures and interpret spatial pathway patterns"
  },
  {
    "objectID": "day2/day2-2_svg_feature_set_signatures.html#load-and-prepare-data",
    "href": "day2/day2-2_svg_feature_set_signatures.html#load-and-prepare-data",
    "title": "Exercise 2",
    "section": "Load and Prepare Data",
    "text": "Load and Prepare Data\nWe begin by loading the SpatialExperiment object prepared in the previous exercise containing clustering results.\n\nspe &lt;- loadHDF5SummarizedExperiment(dir=\"results/day1\", prefix=\"01.4_spe\")"
  },
  {
    "objectID": "day2/day2-2_svg_feature_set_signatures.html#spatially-variable-genes-svgs",
    "href": "day2/day2-2_svg_feature_set_signatures.html#spatially-variable-genes-svgs",
    "title": "Exercise 2",
    "section": "Spatially variable genes (SVGs)",
    "text": "Spatially variable genes (SVGs)\nIn Day 1, we introduced highly variable genes (HVGs), which capture overall transcriptional variability and are useful for identifying major sources of variation and reducing dimensionality. HVGs reflect global heterogeneity, but they do not use spatial information.\nIn spatial transcriptomics, however, we are often interested in genes whose expression changes across tissue in structured spatial patterns. These are called spatially variable genes (SVGs), which conceptually generalize HVGs by adding spatial information.\nSVG methods differ in how they use spatial coordinates and what types of spatial structure they detect. They can be broadly grouped into three categories (Yan, Hua, and Li 2025):\n\nOverall SVGs detect any spatial pattern across the tissue; can be used for feature selection for downstream analyses (e.g., spatially-aware clustering)\nSpatial domain-specific SVGs identify genes whose expression differs between spatial domains, using domains as a proxy for spatial information\nCell type-specific SVGs use external cell type annotations to identify spatially structures expression within cell types.\n\nIn this exercise, we will focus on the first two categories, using nnSVG(Weber et al. 2023) for overall SVGs and DESpace(Cai, Robinson, and Tiberi 2024) for domain-specific SVGs.\n\nset.seed(123)\n# Sample 100 spots to decrease runtime in this exercise\nn &lt;- 100\nsub &lt;- spe[, sample(ncol(spe), n)]\nrowData(sub)$gene_name &lt;- rowData(sub)$Symbol\n\n# Subset to HVGs only to further decrease runtime\nhvg_idx &lt;- which(rowData(spe)$hvg)[seq_len(200)]\nsub &lt;- sub[hvg_idx, ]\n\n# Remove empty spots\nkeep_spots &lt;- colSums(counts(sub)) &gt; 0\nsub &lt;- sub[, keep_spots]\n\n# Remove genes with all zeros\nkeep_genes &lt;- rowSums(counts(sub)) &gt; 0\nsub &lt;- sub[keep_genes, ]\n\n# Remove lowly expressed genes (expressed in ≥1% of spots)\nkeep_genes2 &lt;- rowMeans(counts(sub) &gt; 0) &gt;= 0.01 \nsub &lt;- sub[keep_genes2, ]\n\nsub &lt;- logNormCounts(sub)\ndim(sub)\n\n[1] 199 100\n\n\nnnSVG\nnnSVG detects SVGs by modeling spatial gene expression using Gaussian processes, capturing smooth gradients or spatial trends.\n\nNote: nnSVG may take up to ~10 minutes to run. Feel free to take a short break and grab a coffee! While it is running, you might want to take a look at the nnSVG paper and the package vignette to better understand how the method works, including its handling of covariates and multiple samples.\n\n\nset.seed(123)\nsub &lt;- nnSVG(sub)\n\n\n\n\n\n\n\nExercise 1\n\n\n\nInspect the nnSVG output stored in rowData(sub).\n\nWhat do the result columns represent?\nSelect the top SVGs detected by nnSVG.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Select top SVGs\nres_nnSVG &lt;- rowData(sub)\nhead(res_nnSVG, 3)\n\nDataFrame with 3 rows and 20 columns\n                   ID      Symbol            Type subsets_Mito       hvg\n          &lt;character&gt; &lt;character&gt;        &lt;factor&gt;    &lt;logical&gt; &lt;logical&gt;\nMXRA8 ENSG00000162576       MXRA8 Gene Expression        FALSE      TRUE\nSKI   ENSG00000157933         SKI Gene Expression        FALSE      TRUE\nSPSB1 ENSG00000171621       SPSB1 Gene Expression        FALSE      TRUE\n        gene_name   sigma.sq      tau.sq       phi    loglik   runtime\n      &lt;character&gt;  &lt;numeric&gt;   &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;\nMXRA8       MXRA8 0.00363122 1.54827e-01  16.47343  -49.7733     0.019\nSKI           SKI 0.00723829 1.35309e-01   1.60665  -44.0048     0.023\nSPSB1       SPSB1 0.09714620 9.71462e-10   6.38084   13.6698     0.030\n           mean       var     spcov   prop_sv loglik_lm    LR_stat      rank\n      &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt;  &lt;numeric&gt; &lt;numeric&gt;\nMXRA8 0.1260139 0.1599858  0.478198 0.0229159 -49.75781 -0.0309465       128\nSKI   0.1356530 0.1439653  0.627175 0.0507784 -44.48220  0.9547881        73\nSPSB1 0.0348406 0.0648524  8.945969 1.0000000  -4.60927 36.5581415         4\n             pval        padj\n        &lt;numeric&gt;   &lt;numeric&gt;\nMXRA8 1.00000e+00 1.00000e+00\nSKI   6.20398e-01 1.00000e+00\nSPSB1 1.15213e-08 5.73183e-07\n\ntop_nnSVG &lt;- res_nnSVG$gene_name[seq_len(3)]\n\nThe main output is in rowData of the SpatialExperiment object, which includes: the likelihood ratio statistic (LR_stat), the gene’s rank based on this statistic (rank), raw p-values from a chi-squared test with 2 degrees of freedom (pval), p-values adjusted for multiple testing (padj), and the estimated effect size (prop_sv), defined as the proportion of spatial variance relative to total variance.\n\nIf you did not run nnSVG due to runtime constraints, you may use these pre-computed top SVGs:\n\n\ntop_nnSVG &lt;- c(\"MXRA8\", \"VWA1\", \"SKI\")\n\n\n\n\nDESpace\nDESpace detects genes that show significantly higher/lower expression in one spatial domain compared to the rest of the tissue. To run DESpace, we need cluster labels or manual annotation. Here we use pre-computed spatial clusters from the Day1 exercise 4.\n\nres &lt;- svg_test(sub, cluster_col=\"Banksy\", verbose = TRUE)\n\nusing 'svg_test' for spatial gene/pattern detection.\n\n\nFilter low quality genes: \n\n\nmin_counts = 20; min_non_zero_spots = 10.\n\n\nThe number of genes that pass filtering is 57.\n\n\nsingle sample test\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nHave a look at the DESpace results.\n\nWhat do each element of the returned list represent?\nSelect top SVGs detected by DESpace.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhead(res_DESpace &lt;- res$gene_results, 3)\n\n       gene_id        LR   logCPM       PValue          FDR\nPIGR      PIGR 147.49151 17.05477 2.623290e-29 1.495275e-27\nS100A6  S100A6  87.81435 16.53602 8.613377e-17 2.454812e-15\nREG1A    REG1A  85.86384 16.01696 2.186044e-16 4.153484e-15\n\ntop_DESpace &lt;- res_DESpace$gene_id[seq_len(3)]\n\nThe main output is in gene_results: a data.frame containing: gene name (gene_id), likelihood ratio test statistics (LR), average (across spots) log-2 counts per million (logCPM), raw p-values (PValue) and Benjamini-Hochberg adjusted p-values (FDR).\n\n\n\nComparing HVGs and SVGs\nAs we did yesterday, we first model gene variance using a Poisson noise model with scran::modelGeneVarByPoisson() and select the top HVGs.\n\ndec &lt;- modelGeneVarByPoisson(spe)\ntop_HVG &lt;- row.names(dec[order(dec$bio, decreasing = T), ])[1:3]\ntop_HVG\n\n[1] \"IGKC\"   \"MT-CO3\" \"MT-CO2\"\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\n\nVisualize the expression patterns of the top genes from each list via ggspavis::plotCoords().\nWhat types of biological signals does each category capture?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ngs &lt;- c(\n    nnSVG=top_nnSVG,\n    DESpace=top_DESpace,\n    HVGs=top_HVG)\n# Expression plots for each top gene\nps &lt;- lapply(seq_along(gs), \\(.) {\n    plotCoords(spe,\n        point_size=0,\n        annotate=gs[.],\n        assay_name=\"logcounts\",\n        feature_names=\"Symbol\")\n})\nwrap_plots(ps, nrow=3) & theme(\n    legend.key.width=unit(0.4, \"lines\"),\n    legend.key.height=unit(0.8, \"lines\")) &\n    scale_color_gradientn(colors = pals::parula())\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBonus question\n\n\n\nTry using SVGs for dimensionality reduction (e.g., PCA) and clustering (e.g., Leiden clustering, BayesSpace, Banksy). How do clustering results differ compared to using HVGs?"
  },
  {
    "objectID": "day2/day2-2_svg_feature_set_signatures.html#feature-set-signatures",
    "href": "day2/day2-2_svg_feature_set_signatures.html#feature-set-signatures",
    "title": "Exercise 2",
    "section": "Feature-set signatures",
    "text": "Feature-set signatures\nSo far, we have focused on single genes. We now consider gene set signatures, which summarize activity of pathways or biological program.\nHere we will use AUCell(Aibar et al. 2017), which works in two main steps: (i) rank genes for every cell/spot, and (ii) compute an AUC score per (spot, gene set) pair, roughly reflecting the fraction of high-ranking genes that belong to a given set. High AUC values correspond to high coordinated expression of the gene set.\nRetrieve MSigDB Hallmark gene sets\n\n# Retrieve hallmark gene sets from 'MSigDB'\ndb &lt;- msigdbr(species=\"Homo sapiens\", category=\"H\")\n\nWarning: The `category` argument of `msigdbr()` is deprecated as of msigdbr 10.0.0.\nℹ Please use the `collection` argument instead.\n\n# Get list of gene symbols, one element per set\ngs &lt;- split(db$ensembl_gene, db$gs_name)\n\n# Simplify set identifiers (drop prefix, use lower case)\nnames(gs) &lt;- tolower(gsub(\"HALLMARK_\", \"\", names(gs)))\n\n\n\n\n\n\n\nExercise 4\n\n\n\nHow many gene sets are there? What is the range of gene counts across these sets?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlength(gs)\n\n[1] 50\n\n\n\nrange(sapply(gs, length))\n\n[1]  32 201\n\n\n\n\n\nGene set scoring with AUCell\n\n\n# Realize (sparse) gene expression matrix\nmtx &lt;- as(logcounts(spe), \"dgCMatrix\") \n\n# Use ensembl identifiers as feature names\nrownames(mtx) &lt;- rowData(spe)$ID\n\n# Filter for genes represented in panel\n.gs &lt;- lapply(gs, intersect, rownames(mtx))\n# Keep only those with at least 5 genes\n.gs &lt;- .gs[sapply(.gs, length) &gt;= 5]\n\n# Build per-spot gene rankings\nrnk &lt;- AUCell_buildRankings(mtx, plotStats=FALSE, verbose=FALSE)\n\n# Calculate AUC for each gene set in each spot\nauc &lt;- AUCell_calcAUC(geneSets=.gs, rankings=rnk, verbose=FALSE)\n\n# Add results as spot metadata\ncolData(spe)[rownames(auc)] &lt;- res &lt;- t(assay(auc)) \n\n\n\n\n\n\n\nExercise 5\n\n\n\n\nCalculate the percentage of spots with non-zero AUC scores for each gene set (Hint: use rowMeans()).\nWhich gene sets are rarely detected? Which ones are mostly detected?\nIdentify the gene set with the highest score variability across spots (Hint: corVars()).\nVisualize this top-scoring set in tissue space via ggspavis::plotCoords().\nVisualize how signature scores correlated with one another (Hint: compute Spearman correlations and visualize it with pheatmap()).\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# The percentage of spots with non-zero score across signatures\nfq &lt;- rowMeans(assay(auc) &gt; 0)\nfq &lt;- sort(round(100*fq, 2))\n## Rarely detected\nhead(fq)\n\n       pancreas_beta_cells            notch_signaling \n                     80.86                      83.17 \n        hedgehog_signaling wnt_beta_catenin_signaling \n                     88.61                      91.68 \n            apical_surface               angiogenesis \n                     95.42                      95.66 \n\n## Mostly detected\ntail(fq)\n\noxidative_phosphorylation               p53_pathway   tnfa_signaling_via_nfkb \n                      100                       100                       100 \n           uv_response_dn            uv_response_up     xenobiotic_metabolism \n                      100                       100                       100 \n\n# Subset on highest score variability across spots\n## Variance across spots\nvar &lt;- colVars(res) \n## Top sets\ntop &lt;- names(tail(sort(var), 1)) \n\n# Scale the rows (genes) for better visualization in the heatmap.\nspe[[top]] &lt;- scale(spe[[top]]) \nplotCoords(spe, annotate = top) \n\n\n\n\n\n\n\n\ncm &lt;- cor(t(assay(auc)), method=\"spearman\")\npheatmap(cm, \n    breaks=seq(-1, 1, 0.1), \n    color=pals::coolwarm(20), \n    cellwidth=10, cellheight=10)\n\n\n\n\n\n\n\nHighly correlated sets will exhibit similar spatial patterns.\n\n\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()\n\n\n\n\n\n\n\nImportant\n\n\n\nKey Takeaways:\n\nHVGs and SVGs emphasize different aspects of the data: HVGs (global heterogeneity); SVGs (spatially structured patterns).\nDifferent SVG methods detect different types of structure.\nGene set signatures summarize coordinated activity of biological pathways. and can be mapped across the tissue and compared between regions or clusters."
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html",
    "href": "day1/day1-4_clustering_find_markers.html",
    "title": "Exercise 4",
    "section": "",
    "text": "library(Banksy)\nlibrary(igraph)\nlibrary(ggspavis)\nlibrary(BayesSpace)\nlibrary(nnSVG)\nlibrary(HDF5Array) # For loading object\nlibrary(patchwork)\nlibrary(SpatialExperiment)\nlibrary(scran) \nlibrary(scater)\nlibrary(scrapper)\nlibrary(SingleR)\nlibrary(qs2)\nlibrary(viridis)\nlibrary(RColorBrewer)\nlibrary(pheatmap)"
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html#clustering-and-spatially-aware-clustering",
    "href": "day1/day1-4_clustering_find_markers.html#clustering-and-spatially-aware-clustering",
    "title": "Exercise 4",
    "section": "Clustering and Spatially-aware clustering",
    "text": "Clustering and Spatially-aware clustering\nIn the next section we will explore clustering methods for spatial transcriptomics data, including classical non-spatially aware and spatially-aware approaches."
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html#learning-objectives",
    "href": "day1/day1-4_clustering_find_markers.html#learning-objectives",
    "title": "Exercise 4",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this exercise, you will be able to:\n\nPerform non-spatially aware clustering using graph-based methods (Leiden clustering).\nPerform spatially-aware clustering using Bayesian modeling (BayesSpace) and graph-based methods (Banksy + Leiden).\nVisualize and compare clustering results from different methods on tissue slides."
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html#clustering",
    "href": "day1/day1-4_clustering_find_markers.html#clustering",
    "title": "Exercise 4",
    "section": "Clustering",
    "text": "Clustering\nLoad the previously saved SpatialExperiment object which contains information on the HVGs and dimensionationality reduction computed with Banksy and PCA.\n\nspe &lt;- loadHDF5SummarizedExperiment(dir=\"results/day1\", prefix=\"01.3_spe\")\n\nNon-spatial aware clustering\nClustering methods can be categorized into non-spatially aware, classically used for scRNA-seq analysis, and spatially-aware methods. We will first explore non-spatially aware clustering using graph-based methods.\nLeiden clustering\nAs commonly done in single-cell RNA-seq analysis, we can perform graph-based clustering using the Leiden algorithm on a shared nearest-neighbor (SNN) graph constructed from the PCA results.\n\n# build cellular shared nearest-neighbor (SNN) graph\ng &lt;- buildSNNGraph(spe, use.dimred=\"PCA\", type=\"jaccard\", k=20)\n# cluster using Leiden community detection algorithm\nk &lt;- cluster_leiden(g, objective_function=\"modularity\", resolution=0.6)\n# assign cluster labels to spe object\nspe$Leiden &lt;- factor(k$membership)\ntable(spe$Leiden)\n\n\n   1    2    3    4    5    6    7 \n1844 1471 1459 2238 2302 2201 1100 \n\n\nSpatialy aware clustering\nClustering methods can also incorporate spatial information to identify spatial domains or regions in the tissue. Here we will explore two different approaches: Bayesian modeling (probabilistic) and spatially-aware graph-based clustering.\nProbabilistic: BayesSpace\nWe can use the BayesSpace package to perform spatially aware clustering using a Bayesian modeling approach.\n\n# prepare data for 'BayesSpace'\n# skipping PCA (already computed)\nspe &lt;- spatialPreprocess(spe, skip.PCA=TRUE)\n# perform spatial clustering with 'BayesSpace'\n# using 'd=10' PCs and targeting 'q=8' clusters\nspe &lt;- spatialCluster(spe, q=8, d=10, nrep=1e3, burn.in=100) \nspe$BayesSpace &lt;- factor(spe$spatial.cluster)\ntable(spe$BayesSpace)\n\n\n   1    2    3    4    5    6    7    8 \n1796  524 1716 2495 2592  816 1681  995 \n\n\nGraph-based: Banksy\nWe have computed spatially-aware principal components using Banksy already in the previous practical. We will now used these to perform SNN graph-based Leiden clustering, in order to obtain spatially-aware clusters. When building the SNN graph, we will use the same parameters we have used before for the non-spatially aware graph.\n\n# perform SNN graph-based clustering on 'Banksy' PCs using\ng &lt;- buildSNNGraph(spe, use.dimred=\"PCA_banksy\", type=\"jaccard\", k=20)\n# cluster using Leiden community detection algorithm\nk &lt;- cluster_leiden(g, objective_function=\"modularity\", resolution=0.6)\nspe$Banksy &lt;- factor(k$membership)\ntable(spe$Banksy)\n\n\n   1    2    3    4    5    6    7    8    9 \n1481 1154 1395 1214 2379 1922  953 1565  552"
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html#visualisation-of-the-different-clustering-methods",
    "href": "day1/day1-4_clustering_find_markers.html#visualisation-of-the-different-clustering-methods",
    "title": "Exercise 4",
    "section": "Visualisation of the different clustering methods:",
    "text": "Visualisation of the different clustering methods:\nLet’s visualize the clustering results from the different methods on the tissue slide.\n\n# Define the three clustering methods to compare\nks &lt;- c(\"BayesSpace\", \"Leiden\", \"Banksy\") \n# Plot spatial distribution of clusters for each method\nplots &lt;- c(lapply(ks, \\(.) {\n    plt &lt;- plotVisium(spe, annotate=., zoom = T, point_shape = 22, point_size = 1)\n    plt\n}) ,  \n  plotVisium(spe, zoom = T,  spots=FALSE )) # add a plot of the tissue without spots\n# combine plots\nplots |&gt;  wrap_plots(nrow=2) &\n      scale_fill_brewer(palette = \"Set1\") &\n    theme(legend.key.size=unit(0, \"lines\"), legend.justification=\"left\")\n\n\n\n\n\n\n\nIt can help us to visualise the clusters one by one, in order to better see their spatial distribution. We take as an example the Banksy clusters:\n\n# plot selected clusters in order of frequency,\n# highlighting cells assigned to cluster 'k'\nlapply(tail(names(sort(table(spe$Banksy))), 8), \\(k) {\n    spe$foo &lt;- spe$Banksy == k\n    spe &lt;- spe[, order(spe$foo)]\n    plt &lt;- plotCoords(spe, annotate=\"foo\")\n    plt$layers[[1]]$aes_params$stroke &lt;- 0\n    plt$layers[[1]]$aes_params$size &lt;- 0.2\n    plt + ggtitle(k)\n}) |&gt;\n    wrap_plots(nrow=3) &\n    scale_color_manual(values=c(\"white\", \"red\")) &\n    theme(plot.title=element_text(hjust=0.5), legend.position=\"none\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nVisualise the clusters obtained with the 3 methods, and compare their spatial distribution. What do you observe?"
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html#perform-cell-type-annotation-of-the-spots",
    "href": "day1/day1-4_clustering_find_markers.html#perform-cell-type-annotation-of-the-spots",
    "title": "Exercise 4",
    "section": "Perform cell-type annotation of the spots",
    "text": "Perform cell-type annotation of the spots\nWe’ll use the annotation of the scRNA-seq dataset (10X FLEX technology) generated along with the VisiumHD used in the practicals (See the record on GEO and the related Github repository). We subsetted this reference dataset to 5,000 cells.\nTo annotate each spot, we use the SingleR() method, which uses a correlation-based approach comparing test cells (here: spots) to reference samples with known cell-type annotation.\n\nref.se = qs_read(\"data/Human_Colon_Cancer_P1/NatGenetics2025_CRC_5k.SE.qs\")\ntable(colData(ref.se)$labels)\n\n\n              B cells           Endothelial            Fibroblast \n                  316                   308                   868 \nIntestinal Epithelial               Myeloid              Neuronal \n                  523                   599                   296 \n        Smooth Muscle               T cells                 Tumor \n                  649                   351                  1090 \n\n# Predict cell-type using SingleR \npred &lt;- SingleR(test   = logcounts(spe),\n                ref    = assay(ref.se, \"data\"), # log-normalized counts        \n                labels = ref.se$labels,\n                aggr.ref = TRUE,                # pseudo-bulk aggregation of reference labels  \n                fine.tune = FALSE,              # for faster computation here\n)\nspe$SingleR_label &lt;- pred$pruned.labels\ntable(spe$SingleR_label)\n\n\n              B cells           Endothelial            Fibroblast \n                 1007                   840                  3340 \nIntestinal Epithelial               Myeloid              Neuronal \n                 1633                   656                    66 \n        Smooth Muscle               T cells                 Tumor \n                  505                  1570                  2991 \n\n# visualize the predictions on the tissue slide.\nplotCoords(spe, annotate=\"SingleR_label\", point_shape = 15, point_size = 1) + \n  scale_colour_brewer(palette = \"Set1\")\n\n\n\n\n\n\nplotVisium(spe, annotate=\"SingleR_label\", zoom = T, point_shape = 22, point_size = 1) + \n  scale_fill_brewer(palette = \"Set1\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nWhat do you think about this annotation? Do you identify potentially relevant biological structures? How are these isolated above in the calculated clusters and spatial domains?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nLet’s compare to the Leiden cluster for example:\n\ntab_prop &lt;- prop.table(table(spe$Leiden, spe$SingleR_label), margin = 1)\n## For display: round and remove 0s\nnum_mat &lt;- round(tab_prop, 2)\nnum_mat[num_mat == 0] &lt;- \"\"\n\n## Annotation colors\ngroup_df = data.frame(row.names = colnames(tab_prop), SingleR_label=colnames(tab_prop))\nann_colors = list(\n  SingleR_label = setNames(object = brewer.pal(9, \"Set1\"), colnames(tab_prop)))\n\npheatmap(\n  tab_prop,\n  cluster_rows = TRUE,\n  cluster_cols = TRUE,\n  color = viridis(100, option = \"magma\", direction = -1)[0:50],\n  display_numbers = num_mat,\n  fontsize_number = 10,\n  fontsize = 12,\n  border_color = NA,\n  main = \"Leiden clusters vs. SingleR labels\", \n  annotation_col = group_df,\n  annotation_colors = ann_colors  \n)\n\n\n\n\n\n\n\nSave the object\nSave the SpatialExperiment object for the next steps:\n\nsaveHDF5SummarizedExperiment(spe, dir=\"results/day1\", prefix=\"01.4_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()"
  },
  {
    "objectID": "day1/day1-4_clustering_find_markers.html#save-the-object",
    "href": "day1/day1-4_clustering_find_markers.html#save-the-object",
    "title": "Exercise 4",
    "section": "Save the object",
    "text": "Save the object\nSave the SpatialExperiment object for the next steps:\n\nsaveHDF5SummarizedExperiment(spe, dir=\"results/day1\", prefix=\"01.4_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()"
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html",
    "href": "day1/day1-2_spotsweeper_qc.html",
    "title": "Exercise 2",
    "section": "",
    "text": "In this second exercise, we will focus on the critical step of quality control (QC) for spatial transcriptomics data. This step focuses on removing low-quality spots or technical artifacts from the dataset to avoid biases into downstream analysis."
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#quality-control-at-spot-level",
    "href": "day1/day1-2_spotsweeper_qc.html#quality-control-at-spot-level",
    "title": "Exercise 2",
    "section": "",
    "text": "In this second exercise, we will focus on the critical step of quality control (QC) for spatial transcriptomics data. This step focuses on removing low-quality spots or technical artifacts from the dataset to avoid biases into downstream analysis."
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#learning-objectives",
    "href": "day1/day1-2_spotsweeper_qc.html#learning-objectives",
    "title": "Exercise 2",
    "section": "Learning objectives",
    "text": "Learning objectives\nBy the end of this exercise, you will be able to:\n\nCalculate per-spot QC metrics.\nIdentify local outliers based on various QC metrics.\nDetect spatial artifacts using SpotSweeper.\nVisualize QC metrics and detected artifacts."
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#libraries",
    "href": "day1/day1-2_spotsweeper_qc.html#libraries",
    "title": "Exercise 2",
    "section": "Libraries",
    "text": "Libraries\n\nlibrary(SpatialExperiment)\nlibrary(SpotSweeper)\nlibrary(scuttle)\nlibrary(scater)\nlibrary(ggside)\nlibrary(ggplot2)\nlibrary(escheR) \nlibrary(HDF5Array)\nlibrary(ggspavis)\nlibrary(patchwork)"
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#calculate-qc-metrics",
    "href": "day1/day1-2_spotsweeper_qc.html#calculate-qc-metrics",
    "title": "Exercise 2",
    "section": "Calculate QC metrics",
    "text": "Calculate QC metrics\nWe will start by calculating QC metrics that are also commonly used in scRNA-seq data analysis (number of UMI counts per cell, number of detected genes per cell, percentage of UMIs originating from mitochondrial genes). Here these metrics will be calculated per sport, and used to identify low-quality spots.\nWe will start by loading our SpatialExperiment object, which was saved in the previous exercise, and prepare it for quality control analysis.\n\n# Load the SpatialExperiment object\nspe &lt;- loadHDF5SummarizedExperiment(dir=\"results/day1/\", prefix=\"01.1_spe\")\n\n# Identify mitochondrial genes (genes with symbol starting with \"MT-\")\nis.mito &lt;- rownames(spe)[grepl(\"^MT-\", rownames(spe))]\n\nNow, we will calculate per-spot QC metrics using the scuttle package. The function addPerCellQCMetrics adds metrics mitochondrial gene percentage to the colData of the SpatialExperiment object.\nRun the following code to compute these metrics and inspect the results.\n\nspe &lt;- addPerCellQCMetrics(spe, subsets = list(Mito = is.mito))\n\n\n\n\n\n\n\nExercise 1\n\n\n\nCheck which metadata has been added to colData. Do you recognize the different metrics?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Display the colData to see the newly added QC metrics.\ncolData(spe)\n\nDataFrame with 14207 rows and 12 columns\n                                    barcode in_tissue array_row array_col\n                                &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\ns_016um_00144_00175-1 s_016um_00144_00175-1         1       144       175\ns_016um_00204_00145-1 s_016um_00204_00145-1         1       204       145\ns_016um_00191_00159-1 s_016um_00191_00159-1         1       191       159\ns_016um_00111_00233-1 s_016um_00111_00233-1         1       111       233\ns_016um_00202_00235-1 s_016um_00202_00235-1         1       202       235\n...                                     ...       ...       ...       ...\ns_016um_00217_00238-1 s_016um_00217_00238-1         1       217       238\ns_016um_00192_00176-1 s_016um_00192_00176-1         1       192       176\ns_016um_00214_00240-1 s_016um_00214_00240-1         1       214       240\ns_016um_00193_00227-1 s_016um_00193_00227-1         1       193       227\ns_016um_00109_00223-1 s_016um_00109_00223-1         1       109       223\n                         bin_size   sample_id       sum  detected\n                      &lt;character&gt; &lt;character&gt; &lt;numeric&gt; &lt;integer&gt;\ns_016um_00144_00175-1         016    sample01       322       202\ns_016um_00204_00145-1         016    sample01       253       203\ns_016um_00191_00159-1         016    sample01      1546       982\ns_016um_00111_00233-1         016    sample01       818       665\ns_016um_00202_00235-1         016    sample01       227       195\n...                           ...         ...       ...       ...\ns_016um_00217_00238-1         016    sample01       291       246\ns_016um_00192_00176-1         016    sample01       626       557\ns_016um_00214_00240-1         016    sample01       330       271\ns_016um_00193_00227-1         016    sample01       802       684\ns_016um_00109_00223-1         016    sample01      1020       794\n                      subsets_Mito_sum subsets_Mito_detected\n                             &lt;numeric&gt;             &lt;integer&gt;\ns_016um_00144_00175-1              109                    10\ns_016um_00204_00145-1               37                     7\ns_016um_00191_00159-1              230                    11\ns_016um_00111_00233-1               51                     8\ns_016um_00202_00235-1                7                     5\n...                                ...                   ...\ns_016um_00217_00238-1               10                     6\ns_016um_00192_00176-1                7                     6\ns_016um_00214_00240-1               10                     6\ns_016um_00193_00227-1               19                     7\ns_016um_00109_00223-1               67                    10\n                      subsets_Mito_percent     total\n                                 &lt;numeric&gt; &lt;numeric&gt;\ns_016um_00144_00175-1             33.85093       322\ns_016um_00204_00145-1             14.62451       253\ns_016um_00191_00159-1             14.87710      1546\ns_016um_00111_00233-1              6.23472       818\ns_016um_00202_00235-1              3.08370       227\n...                                    ...       ...\ns_016um_00217_00238-1              3.43643       291\ns_016um_00192_00176-1              1.11821       626\ns_016um_00214_00240-1              3.03030       330\ns_016um_00193_00227-1              2.36908       802\ns_016um_00109_00223-1              6.56863      1020\n\n\n\nThe sum column contains the total number of unique molecular identifiers (UMIs) for each spot\nThe detected column contains the number of unique genes detected per spot\nThe subsets_mito_percent contains the percentage of transcripts mapping to mitochondrial genes per spot\n\n\n\n\nGlobal outlier detection\nIn order to detect low-quality spots and filter them out, QC methods adapted from scRNA-seq analysis can be applied. A simple option is to apply a fixed (upper or lower-bound) threshold to a metric across all spots, and remove the spots that do not pass the filtering criteria applied.\nTo set up these threshold we can look for information from 10X and the community, for example https://github.com/10XGenomics/HumanColonCancer_VisiumHD/issues/28. Based on this discussion the authors of the OSTA book wrote (see “Remove bins overlaying empty tissue” section in https://lmweber.org/OSTA/pages/seq-workflow-visium-hd-bin.html#dependencies):\n\nBased on a discussion with the original author at 10x Genomics, in this dataset, 8 µm bins with a library size below 100 are removed. Since we expect a 4-fold increase in library size across all bins at 16 µm, we can set the filtering threshold to 400.\n\nWe can also have a look and plot distributions of the values to decide which is the best cutoff:\n\n# Plot library size vs. detected genes\np1 &lt;- ggcells(spe, aes(x=detected, y=sum)) + \n  geom_point() +\n  geom_density_2d() +\n  scale_x_log10() +\n  scale_y_log10() +\n  geom_xsidehistogram() + \n  geom_ysidehistogram() + \n  geom_vline(xintercept = 300, col=\"red\", lty=2) +\n  geom_hline(yintercept = 400, col=\"red\", lty=2) +\n  labs(y=\"Number of UMIs\", x=\"Number of detected genes\") +\n  ggtitle(\"Library size vs. detected\")\n\n# Plot mito proportion vs. detected genes\np2 &lt;- ggcells(spe, aes(x=detected, y=subsets_Mito_percent)) + \n  geom_point() +\n  geom_density_2d() +\n  scale_x_log10() +\n  geom_xsidehistogram() + \n  geom_ysidehistogram() + \n  geom_vline(xintercept = 300, col=\"red\", lty=2) +\n  geom_hline(yintercept = 20, col=\"red\", lty=2) +\n  labs(y=\"% mitochondrial reads\", x=\"Number of detected genes\") +\n  ggtitle(\"Mito proportion vs. genes detected\")\n\np1 + p2\n\n\n\n\n\n\n\nAnd further check how many spots would be removed with the given thresholds:\n\n# Flag spots based on fixed thresholds\nspe$qc_lib_size &lt;- spe$sum &lt; 400\nspe$qc_detected &lt;- spe$detected &lt; 300\nspe$qc_mito_prop &lt;- spe$subsets_Mito_percent &gt; 20\n\n# Tabulate number of spots flagged by each\nqc &lt;- grep(\"^qc\", names(colData(spe)))\nsapply(colData(spe)[qc], table)\n\n      qc_lib_size qc_detected qc_mito_prop\nFALSE       11021       11263        12148\nTRUE         3186        2944         2059\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nWhat do you think about this intial filtering?\nHave a look at the mitochondrial percentage numbers on the tissue section using plotVisium() function. Which spots are more likely to be excluded?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nplotVisium(spe, annotate = \"subsets_Mito_percent\", zoom = TRUE)\n\n\n\n\n\n\n\n\n\n\nVisualize spatial pattern of QC metrics (Global outliers)\nVery importantly, we want to have a look into the spatial pattern of using a fixed threshold for QC metrics :\n\n# check spatial pattern of discarded spots\np1 &lt;- plotObsQC(spe, \n                plot_type=\"spot\", annotate=\"qc_lib_size\") + \n  ggtitle(\"Library size (&lt; 400 UMI)\")\n\np2 &lt;- plotObsQC(spe, \n                plot_type=\"spot\", annotate=\"qc_detected\") + \n  ggtitle(\"Detected genes (&lt; 300 genes)\")\n\np3 &lt;- plotObsQC(spe, \n                plot_type=\"spot\", annotate=\"qc_mito_prop\") + \n  ggtitle(\"Mito proportion (&gt; 20%)\")\n\n# plot the three together\ngridExtra::grid.arrange(p1, p2, p3, ncol=2)\n\n\n\n\n\n\n\nLocal Outlier Detection\nTo avoid discarding whole layers of tissues, another approach to identify low-quality spots is to use local outlier detection methods that take into account the spatial context of each spot.\nSpotSweeper package provides functions to identify common QC metrics (such as the ones we have seen in the previous section: library size, number of detected genes, and mitochondrial percentage) and detect local outliers based on these metrics.\nWe will use localOutliers from SpotSweeper which helps identifying spots that deviate significantly from their local neighborhood.\n\n# Identify local outliers based on library size (\"sum\" of counts).\n# Spots with unusually low library size compared to their neighbors will be flagged.\nspe &lt;- localOutliers(spe,\n  metric = \"sum\",\n  direction = \"lower\",\n  log = TRUE\n)\n\n# Identify local outliers based on the number of unique genes detected (\"detected\").\n# Spots with an unusually low number of detected genes will be flagged.\nspe &lt;- localOutliers(spe,\n  metric = \"detected\",\n  direction = \"lower\",\n  log = TRUE\n)\n\n# Identify local outliers based on the mitochondrial gene percentage.\n# Spots with an unusually high mitochondrial percentage will be flagged.\nspe &lt;- localOutliers(spe,\n  metric = \"subsets_Mito_percent\",\n  direction = \"higher\",\n  log = FALSE\n)\n\n# Combine all individual outlier flags into a single \"local_outliers\" column.\n# A spot is considered a local outlier if it's flagged by any of the above metrics.\nspe$local_outliers &lt;- as.logical(spe$sum_outliers) |\n  as.logical(spe$detected_outliers) |\n  as.logical(spe$subsets_Mito_percent_outliers)\n\n\n\n\n\n\n\nExercise 3\n\n\n\nHow many spots were identified as local outliers based on the combined criteria?\nAs we have seen before, visualizing the QC metrics is crucial for understanding the quality of your spatial transcriptomics data and for deciding on appropriate filtering strategies, so look at their spatial localization using the plotObsQC function.\nWhat do you think?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Count the number of spots flagged as local outliers.\ntable(spe$local_outliers)\n\n\nFALSE  TRUE \n14036   171 \n\nplotObsQC(spe, \n          plot_type=\"spot\", annotate=\"local_outliers\") + \n  ggtitle(\"All local outliers\")\n\n\n\n\n\n\n\nEven better, we can visualize the spatial distribution of the local outliers together with the QC metrics, for example plot the spatial distribution of local outliers for mitochondrial percentage.\n\nplotQCmetrics(spe,\n  metric = \"subsets_Mito_percent\", outliers = \"subsets_Mito_percent_outliers\",\n  point_size = 0.4,\n  stroke = 0.75\n) +\n  ggtitle(\"Local outliers for %MT\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nPlot the spatial distribution of local outliers for library size and number of detected genes. What do you observe?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Plot the spatial distribution of local outliers for library size.\nplotQCmetrics(spe,\n  metric = \"sum_log\", outliers = \"sum_outliers\", point_size = 0.4,\n  stroke = 0.75\n) +\n  ggtitle(\"Local outliers for number of UMIs\")\n\n\n\n\n\n\n\n\n# Plot the spatial distribution of local outliers for number of detected genes.\nplotQCmetrics(spe,\n  metric = \"detected_log\", outliers = \"detected_outliers\", point_size = 0.4,\n  stroke = 0.75\n) +\n  ggtitle(\"Local outliers for number of UMIs\")\n\n\n\n\n\n\n\nVery few spots seem to be flagged as outliers!\n\n\n\nWe can visualisaze the z-scores from the local outlier detection test, and compare it to the global threshold used earlier. How do you interpret this?\n\nplotObsQC(spe, plot_type = \"violin\", x_metric = \"subsets_Mito_percent_z\", annotate = \"qc_mito_prop\")\n\n\n\n\n\n\n\nCompare and combine global and local outliers and apply filtering\nBased on the comparison of global and local outliers, we choose here to adjust the global cutoffs to be less stringent:\nAdjust global filtering cutoffs based on previous plots (apply less stringent cutoffs)\n\n# adjust global filtering cutoff\nspe$qc_lib_size &lt;- spe$sum &lt; 120\nspe$qc_detected &lt;- spe$detected &lt; 100\nspe$qc_mito_prop &lt;- spe$subsets_Mito_percent &gt; 35\n\nCompare global and local outliers being flagged\n\nspe$global_outliers &lt;- spe$qc_lib_size | spe$qc_detected | spe$qc_mito_prop\np1 &lt;- plotObsQC(spe, plot_type=\"spot\", annotate=\"global_outliers\")\np2 &lt;- plotObsQC(spe, plot_type=\"spot\", annotate=\"local_outliers\")\ngridExtra::grid.arrange(p1, p2, ncol=2)\n\n\n\n\n\n\n\nCombine both:\n\n# combine local and global outliers to create a final discard flag\nspe$discard &lt;- spe$global_outliers | spe$local_outliers\n\n\n\n\n\n\n\nExercise 5\n\n\n\nVisualise the spots that will be discarded based on the combined criteria. How many spots will be removed?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# check how many spots will be discarded\ntable(spe$discard)\n\n\nFALSE  TRUE \n12615  1592 \n\n# have a final look to the spots that we will discard\nplotVisium(spe, zoom=T, annotate=\"discard\")\n\n\n\n\n\n\n\n\n\n\nTechnical artifacts\nTechnical artifacts can arise during tissue preparation, for example tissue dissection can cause mechanical damage, leading to large areas with artificially low biological heterogeneity. These can be detected with the findArtifacts function of the spotSweeper package.\n\n# find artifacts using SpotSweeper\nspe &lt;- findArtifacts(spe,\n    mito_percent = \"subsets_Mito_percent\",\n    mito_sum = \"subsets_Mito_sum\",\n    n_order = 5,\n    name = \"artifact\"\n)\n\n\n\n\n\n\n\nExercise 6\n\n\n\nWhat is the findArtifacts function performing and what are the (potentially problematic) assumptions?\n\n\n\n\n\n\n\n\nExercise 7\n\n\n\nPlot the spatial distribution of the artifact column identified by SpotSweeper. What do you observe?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Plot the spatial distribution of the detected artifacts.\nplotQCmetrics(spe,\n    metric = \"subsets_Mito_percent\", # You can choose any relevant metric to display\n    outliers = \"artifact\", \n    point_size = 1.1\n) +\n    ggtitle(\"Detected Spatial Artifacts\")\n\n\n\n\n\n\n\n\n\n\nFiltering\nWe decide to filter out the low-quality spots from the SpatialExperiment object based on the combined criteria of global thresholds and local outliers. Additionally, we will remove any features (genes) that have zero counts across all remaining spots.\n\n# remove the spots considered of low quality based on both global and local metrics\nspe &lt;- spe[, !spe$discard]\n\n# remove features with all 0 counts\nspe &lt;- spe[rowSums(counts(spe)) &gt; 0, ]\n\nWhat is the size of the dataset after filtering?\nSave the object\nSave the filtered SpatialExperiment object for the next steps:\n\nsaveHDF5SummarizedExperiment(spe, dir=\"results/day1\", prefix=\"01.2_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()\n\n\n\n\n\n\n\nImportant\n\n\n\nKey Takeaways:\n\n\nscuttle::addPerCellQCMetrics provides essential per-spot QC metrics.\n\nSpotSweeper::localOutliers helps identify individual problematic spots.\n\nSpotSweeper::findArtifacts is powerful for detecting spatially coherent regions of poor quality.\nVisualizing QC results is critical for data interpretation and downstream analysis decisions."
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#compare-and-combine-global-and-local-outliers-and-apply-filtering",
    "href": "day1/day1-2_spotsweeper_qc.html#compare-and-combine-global-and-local-outliers-and-apply-filtering",
    "title": "Exercise 2",
    "section": "Compare and combine global and local outliers and apply filtering",
    "text": "Compare and combine global and local outliers and apply filtering\nBased on the comparison of global and local outliers, we choose here to adjust the global cutoffs to be less stringent:\nAdjust global filtering cutoffs based on previous plots (apply less stringent cutoffs)\n\n# adjust global filtering cutoff\nspe$qc_lib_size &lt;- spe$sum &lt; 120\nspe$qc_detected &lt;- spe$detected &lt; 100\nspe$qc_mito_prop &lt;- spe$subsets_Mito_percent &gt; 35\n\nCompare global and local outliers being flagged\n\nspe$global_outliers &lt;- spe$qc_lib_size | spe$qc_detected | spe$qc_mito_prop\np1 &lt;- plotObsQC(spe, plot_type=\"spot\", annotate=\"global_outliers\")\np2 &lt;- plotObsQC(spe, plot_type=\"spot\", annotate=\"local_outliers\")\ngridExtra::grid.arrange(p1, p2, ncol=2)\n\n\n\n\n\n\n\nCombine both:\n\n# combine local and global outliers to create a final discard flag\nspe$discard &lt;- spe$global_outliers | spe$local_outliers\n\n\n\n\n\n\n\nExercise 5\n\n\n\nVisualise the spots that will be discarded based on the combined criteria. How many spots will be removed?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# check how many spots will be discarded\ntable(spe$discard)\n\n\nFALSE  TRUE \n12615  1592 \n\n# have a final look to the spots that we will discard\nplotVisium(spe, zoom=T, annotate=\"discard\")"
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#technical-artifacts",
    "href": "day1/day1-2_spotsweeper_qc.html#technical-artifacts",
    "title": "Exercise 2",
    "section": "Technical artifacts",
    "text": "Technical artifacts\nTechnical artifacts can arise during tissue preparation, for example tissue dissection can cause mechanical damage, leading to large areas with artificially low biological heterogeneity. These can be detected with the findArtifacts function of the spotSweeper package.\n\n# find artifacts using SpotSweeper\nspe &lt;- findArtifacts(spe,\n    mito_percent = \"subsets_Mito_percent\",\n    mito_sum = \"subsets_Mito_sum\",\n    n_order = 5,\n    name = \"artifact\"\n)\n\n\n\n\n\n\n\nExercise 6\n\n\n\nWhat is the findArtifacts function performing and what are the (potentially problematic) assumptions?\n\n\n\n\n\n\n\n\nExercise 7\n\n\n\nPlot the spatial distribution of the artifact column identified by SpotSweeper. What do you observe?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Plot the spatial distribution of the detected artifacts.\nplotQCmetrics(spe,\n    metric = \"subsets_Mito_percent\", # You can choose any relevant metric to display\n    outliers = \"artifact\", \n    point_size = 1.1\n) +\n    ggtitle(\"Detected Spatial Artifacts\")\n\n\n\n\n\n\n\n\n\n\nFiltering\nWe decide to filter out the low-quality spots from the SpatialExperiment object based on the combined criteria of global thresholds and local outliers. Additionally, we will remove any features (genes) that have zero counts across all remaining spots.\n\n# remove the spots considered of low quality based on both global and local metrics\nspe &lt;- spe[, !spe$discard]\n\n# remove features with all 0 counts\nspe &lt;- spe[rowSums(counts(spe)) &gt; 0, ]\n\nWhat is the size of the dataset after filtering?\nSave the object\nSave the filtered SpatialExperiment object for the next steps:\n\nsaveHDF5SummarizedExperiment(spe, dir=\"results/day1\", prefix=\"01.2_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()\n\n\n\n\n\n\n\nImportant\n\n\n\nKey Takeaways:\n\n\nscuttle::addPerCellQCMetrics provides essential per-spot QC metrics.\n\nSpotSweeper::localOutliers helps identify individual problematic spots.\n\nSpotSweeper::findArtifacts is powerful for detecting spatially coherent regions of poor quality.\nVisualizing QC results is critical for data interpretation and downstream analysis decisions."
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#filtering",
    "href": "day1/day1-2_spotsweeper_qc.html#filtering",
    "title": "Exercise 2",
    "section": "Filtering",
    "text": "Filtering\nWe decide to filter out the low-quality spots from the SpatialExperiment object based on the combined criteria of global thresholds and local outliers. Additionally, we will remove any features (genes) that have zero counts across all remaining spots.\n\n# remove the spots considered of low quality based on both global and local metrics\nspe &lt;- spe[, !spe$discard]\n\n# remove features with all 0 counts\nspe &lt;- spe[rowSums(counts(spe)) &gt; 0, ]\n\nWhat is the size of the dataset after filtering?"
  },
  {
    "objectID": "day1/day1-2_spotsweeper_qc.html#save-the-object",
    "href": "day1/day1-2_spotsweeper_qc.html#save-the-object",
    "title": "Exercise 2",
    "section": "Save the object",
    "text": "Save the object\nSave the filtered SpatialExperiment object for the next steps:\n\nsaveHDF5SummarizedExperiment(spe, dir=\"results/day1\", prefix=\"01.2_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()\n\n\n\n\n\n\n\nImportant\n\n\n\nKey Takeaways:\n\n\nscuttle::addPerCellQCMetrics provides essential per-spot QC metrics.\n\nSpotSweeper::localOutliers helps identify individual problematic spots.\n\nSpotSweeper::findArtifacts is powerful for detecting spatially coherent regions of poor quality.\nVisualizing QC results is critical for data interpretation and downstream analysis decisions."
  },
  {
    "objectID": "day1/day1-0_setup.html",
    "href": "day1/day1-0_setup.html",
    "title": "Setup",
    "section": "",
    "text": "Login and set up\nChoose one of the following:\n\n\nEnrolled: if you are enrolled in a course with a teacher\n\nOwn installation: if you want to install packages on your own local Rstudio installation\n\nDocker: if you want to use the docker image locally\n\n\n\nEnrolled\nOwn installation\nDocker\n\n\n\nLog in to Rstudio server with the provided link, username and password.\n\n\nInstall the required packages using renv\n\ninstall.packages(\"renv\")\n\nrenv::restore(lockfile = \"https://raw.githubusercontent.com/sib-swiss/seq-spatial-transcriptomics-training/refs/heads/main/renv.lock\")\n\n\n\nWith docker, you can use exactly the same environment as we use in the enrolled course, but than running locally.\nIn the video below there’s a short tutorial on how to set up a docker container for this course. Note that you will need administrator rights, and that if you are using Windows, you need the latest version of Windows 10.\nThe command to run the environment required for this course looks like this (in a terminal):\n\n\n\n\n\n\nModify the script\n\n\n\nThe home directory within the container is mounted to your current directory ($PWD), if you want to change this behaviour, modify the path after -v to the working directory on your computer before running it.\n\n\n\ndocker run \\\n--rm \\\n-p 8787:8787 \\\n-e PASSWORD=test \\\n-v $PWD:/home/rstudio \\\nsibswiss/training-seq-spatial-transcriptomics-rstudio\n\nIf this command has run successfully, approach Rstudio server like this:\nhttp://localhost:8787\nCopy this URL into your browser. If you used the snippet above, the credentials will be:\n\n\nUsername: rstudio\n\n\nPassword: test\n\n\nGreat! Now you will be able to use Rstudio with all required installations.\n\n\n\n\n\n\nAbout the options\n\n\n\nThe option -v mounts a local directory in your computer to the directory /home/rstudio in the docker container (‘rstudio’ is the default user for Rstudio containers). In that way, you have files available both in the container and on your computer. Use this directory on your computer. Change the first path to a path on your computer that you want to use as a working directory.\nThe part sibswiss/training-seq-spatial-transcriptomics-rstudio is the image we are going to load into the container. The image contains all the information about software and dependencies needed for this course. When you run this command for the first time it will download the image. Once it’s on your computer, it will start immediately.\n\n\n\n\n\nCreate a project\nNow that you have access to an environment with the required installations, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project…\n\nContinue by choosing New Directory\n\nAs project type select New Project\n\nFinally, type in the project name. This should be spatial_course. Finish by clicking Create Project.\n\nWe have setup a project and a project directory (it is in /home/rstudio/spatial_course)."
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html",
    "href": "day1/day1-1_SpatialExperiment.html",
    "title": "Exercise 1",
    "section": "",
    "text": "By the end of this exercise, you will be able to:\n\nUnderstand the structure of a SpatialExperiment object.\nAccess and interpret spatialCoords and imgData.\nPerform basic subsetting operations on SpatialExperiment objects.\nCombine multiple SpatialExperiment objects.\nApply image transformations (rotation, mirroring) to spatial data."
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html#learning-objectives",
    "href": "day1/day1-1_SpatialExperiment.html#learning-objectives",
    "title": "Exercise 1",
    "section": "",
    "text": "By the end of this exercise, you will be able to:\n\nUnderstand the structure of a SpatialExperiment object.\nAccess and interpret spatialCoords and imgData.\nPerform basic subsetting operations on SpatialExperiment objects.\nCombine multiple SpatialExperiment objects.\nApply image transformations (rotation, mirroring) to spatial data."
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html#libraries",
    "href": "day1/day1-1_SpatialExperiment.html#libraries",
    "title": "Exercise 1",
    "section": "Libraries",
    "text": "Libraries\n\n# Load necessary R libraries for spatial transcriptomics data analysis.\nlibrary(SpatialExperiment)\nlibrary(VisiumIO)\nlibrary(arrow)\nlibrary(qs2)\nlibrary(ggspavis)\nlibrary(patchwork)\nlibrary(dplyr)\nlibrary(arrow)\nlibrary(scuttle)\nlibrary(HDF5Array)"
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html#data-for-the-course",
    "href": "day1/day1-1_SpatialExperiment.html#data-for-the-course",
    "title": "Exercise 1",
    "section": "Data for the course",
    "text": "Data for the course\nWe will start with downloading the data. We will work on a VisiumHD dataset from a human colon cancer study published recently. A Visium HD slide from one patient (P2CRC) used in the article is available from the 10X website. We will focus on the “binned output” provided available as an output of the Space Ranger pipeline.\nThe dataset contains normal adjacent tissue (NAT) and colorectal carcinoma (CRC) from 5 patients.\nWe will start downloading and processing one of the Human colon cancer samples (P1).\n\n\n\n\n\n\nExercise 1a\n\n\n\nHave a look at the paper and 10X website, to find out how was the tissue processed for spatial profiling. How are the transcript molecules measured?\nWhich version of the Space Ranger tool was used to process the data, and what is the output folders containing? This page will be useful: https://www.10xgenomics.com/support/software/space-ranger/latest/analysis/outputs/output-overview. Additionally the Space Ranger “web summary” gives a good idea about the quality of the processed sample: https://cf.10xgenomics.com/samples/spatial-exp/3.0.0/Visium_HD_Human_Colon_Cancer/Visium_HD_Human_Colon_Cancer_web_summary.html\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe measurements of RNA molecules is indirect, through capture of ligated probe pairs targeting the whole protein-coding transcriptome.\nAn instrument called Visium CytAssist is used to control reagent flow and better capture target probes from the tissue (in particular to limit problematic free diffusion of transcripts).\nThe dataset was processed with Space Ranger version 3.0.0. Note that this is not the latest version: v4.0 is the latest and it has cool feature, such as a segmented output.\n\n\n\n\nif (!dir.exists(\"data/Human_Colon_Cancer_P1/binned_outputs/\")) {\n  dir.create(\"data\")\n  download.file(\n    url = \"https://seq-spatial-transcriptomics-training.s3.eu-central-1.amazonaws.com/Human_Colon_Cancer_P1.tar.gz\",\n    destfile = \"data/Human_Colon_Cancer_P1.tar.gz\"\n  )\n\n  untar(\n    tarfile = \"data/Human_Colon_Cancer_P1.tar.gz\", exdir = \"data/\"\n  )\n\n  file.remove(\"data/Human_Colon_Cancer_P1.tar.gz\")\n} else {\n  message(\"Data exists, please proceed to next steps!\")\n}\n\nWe will import the dataset into a SpatialExperiment object. For these exercises, we choose to use the largest bin size of 16 µm, and we will subset the dataset for faster processing during the practicals:\n\n# Import Visium HD data from Space Ranger output into a SpatialExperiment object.\nspe &lt;- TENxVisiumHD(\n  spacerangerOut = \"data/Human_Colon_Cancer_P1/\",\n  processing = \"filtered\",\n  format = \"h5\",\n  images = \"lowres\",\n  bin_size = \"016\"\n) |&gt;\n  import()\n\n# we subset the dataset based on x and y coordinates of the tissue slice\nspe &lt;- spe[, spatialCoords(spe)[, 1] * scaleFactors(spe) &gt; 70 &\n  spatialCoords(spe)[, 1] * scaleFactors(spe) &lt; 130 &\n  spatialCoords(spe)[, 2] * scaleFactors(spe) &gt; 200 &\n  spatialCoords(spe)[, 2] * scaleFactors(spe) &lt; 260]\n\n\n\n\n\n\n\nExercise 1b\n\n\n\nWhat other bin sizes are available? Which is the smallest capture unit and what do the other bin sizes mean? Why wouldn’t you always want to work with the smallest available bin?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nIn data/Human_Colon_Cancer_P1/binned_outputs you will find three directories:\nsquare_002um\nsquare_008um\nsquare_016um\nThe capture bins are 2µm^2 (adjacent) on the VisiumHD slide, see Fig. 2a in the paper. Larger bins are pools of 2 µm bins (16 bins for an 8 µm bin, 64 bins for a 16 µm bin). Working with those could be handy because the number of molecules captured will be higher, reducing the sparsity of the data at the cost of resolution."
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html#exploring-the-object",
    "href": "day1/day1-1_SpatialExperiment.html#exploring-the-object",
    "title": "Exercise 1",
    "section": "Exploring the object",
    "text": "Exploring the object\nIn this first exercise, we will dive into the SpatialExperiment object, a cornerstone of spatial transcriptomics analysis in R. We will explore the different components of the loaded object, and perform basic manipulations. By the end of this session, you will have a solid understanding of how to handle spatial transcriptomics data within the R/Bioconductor ecosystem.\n\n\nOverview of the SpatialExperiment class structure\n\nThe different slots of the SpatialExperiment object can be approached with several accessor functions that correspond to their names. As the SpatialExperiment is an extension of the SingleCellExperiment class, methods developed to be applied on SingleCellExperiment objects (or by extension on SummarizedExperiment objects) can also be applied.\n\n\n\n\n\n\nExercise 2\n\n\n\nCheck out the outputs of the following functions, that you should already be familiar with:\n\ncolData()\nrowData()\nassay()\nreducedDims()\n\nCheck out the outputs of the following functions, which are specific to the SpatialExperiment class:\n\nspatialCoords()\nimgData()\nimgRaster()\n\nQuestions:\n\nWhat kind of data is in the different slots?\nHow many spots and genes do we have retained in the spe object?\nAre all spots within the tissue area?\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe slot colData contains metadata of each of the 14207 spots:\n\ncolData(spe) |&gt; head()\n\nDataFrame with 6 rows and 6 columns\n                                    barcode in_tissue array_row array_col\n                                &lt;character&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;\ns_016um_00144_00175-1 s_016um_00144_00175-1         1       144       175\ns_016um_00204_00145-1 s_016um_00204_00145-1         1       204       145\ns_016um_00191_00159-1 s_016um_00191_00159-1         1       191       159\ns_016um_00111_00233-1 s_016um_00111_00233-1         1       111       233\ns_016um_00202_00235-1 s_016um_00202_00235-1         1       202       235\ns_016um_00102_00186-1 s_016um_00102_00186-1         1       102       186\n                         bin_size   sample_id\n                      &lt;character&gt; &lt;character&gt;\ns_016um_00144_00175-1         016    sample01\ns_016um_00204_00145-1         016    sample01\ns_016um_00191_00159-1         016    sample01\ns_016um_00111_00233-1         016    sample01\ns_016um_00202_00235-1         016    sample01\ns_016um_00102_00186-1         016    sample01\n\nncol(spe)\n\n[1] 14207\n\n\nWe have a column in_tissue here, and we can check whether spots are covered by the tissue:\n\ncolData(spe) |&gt;\n  as.data.frame() |&gt;\n  group_by(in_tissue) |&gt;\n  summarise(number = n())\n\n# A tibble: 1 × 2\n  in_tissue number\n      &lt;int&gt;  &lt;int&gt;\n1         1  14207\n\n\nThe slot rowData contains metadata about the 18085 genes for which we measured expression:\n\nrowData(spe) |&gt; head()\n\nDataFrame with 6 rows and 3 columns\n                             ID      Symbol            Type\n                    &lt;character&gt; &lt;character&gt;        &lt;factor&gt;\nENSG00000187634 ENSG00000187634      SAMD11 Gene Expression\nENSG00000188976 ENSG00000188976       NOC2L Gene Expression\nENSG00000187961 ENSG00000187961      KLHL17 Gene Expression\nENSG00000187583 ENSG00000187583     PLEKHN1 Gene Expression\nENSG00000187642 ENSG00000187642       PERM1 Gene Expression\nENSG00000188290 ENSG00000188290        HES4 Gene Expression\n\nnrow(spe)\n\n[1] 18085\n\n\nThe assay is the core count matrix of the object, corresponding to all genes (rows) and all spots (columns):\n\nassay(spe)\n\n&lt;18085 x 14207&gt; sparse DelayedMatrix object of type \"integer\":\n                s_016um_00144_00175-1 ... s_016um_00109_00223-1\nENSG00000187634                     0   .                     0\nENSG00000188976                     0   .                     0\nENSG00000187961                     0   .                     0\nENSG00000187583                     0   .                     0\nENSG00000187642                     0   .                     0\n            ...                     .   .                     .\nENSG00000212907                     7   .                     5\nENSG00000198886                    29   .                    15\nENSG00000198786                     0   .                     1\nENSG00000198695                     2   .                     1\nENSG00000198727                    11   .                    11\n\n\nThe slot for reducedDims is empty for now, as we didn’t perform any dimensionality reduction calculations yet:\n\nreducedDims(spe)\n\nList of length 0\nnames(0): \n\n\nThe slot spatialCoords maps each spot to the full resolution image:\n\nspatialCoords(spe) |&gt; head()\n\n                      pxl_col_in_fullres pxl_row_in_fullres\ns_016um_00144_00175-1          10076.365           28256.34\ns_016um_00204_00145-1           8356.073           24733.65\ns_016um_00191_00159-1           9167.045           25500.94\ns_016um_00111_00233-1          13447.496           30216.22\ns_016um_00202_00235-1          13613.955           24899.03\ns_016um_00102_00186-1          10696.244           30716.82\n\n\nThe slot imgData lists all available images linked to the dataset, their resolution and a scaling factor used to convert pixels coordinates relative to the full resolution image coordinates (above).\n\nimgData(spe)\n\nDataFrame with 1 row and 4 columns\n    sample_id    image_id   data scaleFactor\n  &lt;character&gt; &lt;character&gt; &lt;list&gt;   &lt;numeric&gt;\n1    sample01      lowres   ####  0.00843811\n\n\nThe H&E image can be exported asa raster image for plotting using:\n\nimgRaster(spe) |&gt; plot()\n\n\n\n\n\n\n\n\n\n\nWe saw that the rownames of the object were Ensembl IDs. However, it’s more convenient to have gene symbols. Therefore, we replace the Ensembl IDs, with the symbols stored in rowData (making sure to keep the ensembl ID if these are not unique):\n\nrownames(spe) &lt;- uniquifyFeatureNames(ID = rowData(spe)$ID, names = rowData(spe)$Symbol)\n\nTo get a visual overview the slide we can use ggspavis::plotVisium. First without spots:\n\nplotVisium(spe, spots = FALSE)\n\n\n\n\n\n\n\nAnd with spots overlayed:\n\nplotVisium(spe, point_shape = 22, point_size = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nWhy do we see only spots in a specific area?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nAfter loading the object above, we subsetted the dataset for faster processing. Therefore we only see the spots overlayed with the selected area. You can also visualize only the selected area with the zoom option, see next exercise.\n\n\n\nIt’s possible to colour spots according to some variable, e.g., the number of read counts for a selected gene (i.e., PIGR):\n\nplotVisium(spe,\n  annotate = \"PIGR\",\n  assay = \"counts\",\n  zoom = TRUE,\n  point_size = 1,\n  point_shape = 22\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nCheck out the usage of plotVisium with ?plotVisium. Create a plot that zooms into the spots, and colors the spots according to column array_row.\nIn which slot is array_row stored and what does it represent?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nThe column array_row is stored in colData, it represents in which row the spot is positioned. Of course, plotting this value is not particularly useful for biology. We will visualize more sensible values in the next chapter, when we do the quality control.\nWe use the argument annotate to color according to a column in colData, and we zoom in by specifying zoom = TRUE:\n\np &lt;- plotVisium(spe, annotate = \"array_row\", zoom = TRUE, point_shape = 22)\np"
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html#retain-only-observations-that-map-to-tissue",
    "href": "day1/day1-1_SpatialExperiment.html#retain-only-observations-that-map-to-tissue",
    "title": "Exercise 1",
    "section": "Retain only observations that map to tissue",
    "text": "Retain only observations that map to tissue\n\n\n\n\n\n\nExercise 5\n\n\n\nSubset the SpatialExperiment object (and save it into a new object) to retain only spots that are within the tissue area\nHow many spots were present in “spe” object? And how many are left after selecting for in-tissue spots only (object sub)?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Subset to in-tissue spots only\nsub &lt;- spe[, colData(spe)$in_tissue]\n\n\n# Check dimensions of original and subsetted objects\ndim(spe)\n\n[1] 18085 14207\n\ndim(sub)\n\n[1] 18085 14207\n\n\nBoth objects have the same dimensions. Our spe object is a subset of tissue slice were all spots map tissue. Therefore the filtering here is not relevant."
  },
  {
    "objectID": "day1/day1-1_SpatialExperiment.html#save-the-object",
    "href": "day1/day1-1_SpatialExperiment.html#save-the-object",
    "title": "Exercise 1",
    "section": "Save the object",
    "text": "Save the object\nSave the filtered SpatialExperiment object for the next steps:\n\ndir.create(\"results/day1\", showWarnings = FALSE, recursive = TRUE)\nsaveHDF5SummarizedExperiment(spe,\n  dir = \"results/day1\", prefix = \"01.1_spe\", replace = TRUE,\n  chunkdim = NULL, level = NULL, as.sparse = NA,\n  verbose = NA\n)\n\nClear your environment\n\nrm(list = ls())\ngc()\n.rs.restartR()\n\n\n\n\n\n\n\nImportant\n\n\n\nKey Takeaways:\n\nThe SpatialExperiment class is a versatile container for spatial transcriptomics data.\nIt allows for easy access and manipulation of spatial coordinates, image data, and assay data.\nVarious operations like subsetting, combining, and image transformations can be performed efficiently."
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html",
    "href": "day1/day1-3_feature_dimred_cluster.html",
    "title": "Exercise 3",
    "section": "",
    "text": "In this section we will focus on normalisation, feature selection and dimensionality reduction of spatial transcriptomics data, which are important preprocessing steps before downstream analysis such as clustering and marker gene identification. We will focus on the specific challenges and considerations when dealing with spatially-resolved transcriptomics data, as opposed to traditional single-cell RNA-seq data."
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#normalisation-feature-selection-and-dimensionality-reduction",
    "href": "day1/day1-3_feature_dimred_cluster.html#normalisation-feature-selection-and-dimensionality-reduction",
    "title": "Exercise 3",
    "section": "",
    "text": "In this section we will focus on normalisation, feature selection and dimensionality reduction of spatial transcriptomics data, which are important preprocessing steps before downstream analysis such as clustering and marker gene identification. We will focus on the specific challenges and considerations when dealing with spatially-resolved transcriptomics data, as opposed to traditional single-cell RNA-seq data."
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#learning-objectives",
    "href": "day1/day1-3_feature_dimred_cluster.html#learning-objectives",
    "title": "Exercise 3",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this exercise, you will be able to:\n\nNormalize spatial transcriptomics data to account for technical variations.\nPerform feature selection to identify highly variable genes (HVGs).\nApply dimensionality reduction techniques like PCA.\nVisualize the results of dimensionality reduction in both reduced dimension space and spatial context."
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#libraries",
    "href": "day1/day1-3_feature_dimred_cluster.html#libraries",
    "title": "Exercise 3",
    "section": "Libraries",
    "text": "Libraries\n\nlibrary(SpatialExperiment)\nlibrary(scran) \nlibrary(scater) \nlibrary(ggplot2)\nlibrary(patchwork) \nlibrary(bluster)\nlibrary(escheR) \nlibrary(pheatmap)\nlibrary(HDF5Array) \nlibrary(ggspavis)\nlibrary(nnSVG)\nlibrary(Banksy)\nlibrary(igraph)"
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#load-spatialexperiment-object",
    "href": "day1/day1-3_feature_dimred_cluster.html#load-spatialexperiment-object",
    "title": "Exercise 3",
    "section": "Load SpatialExperiment Object",
    "text": "Load SpatialExperiment Object\nWe will start by loading the SpatialExperiment object from the previous exercise, which contains only filtered spots and genes with more than 1 count across all spots.\n\n# Load the SpatialExperiment object from the .qs2 file.\nspe &lt;- loadHDF5SummarizedExperiment(dir=\"results/day1/\", prefix=\"01.2_spe\")"
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#normalization",
    "href": "day1/day1-3_feature_dimred_cluster.html#normalization",
    "title": "Exercise 3",
    "section": "Normalization",
    "text": "Normalization\nNormalization is a critical step in preprocessing spatial transcriptomics data to account for technical variations and make gene expression levels comparable across spots. We will log normalise raw counts with scuttle::logNormCounts()\n\n# Log-normalize counts for downstream analysis\nspe &lt;- logNormCounts(spe)\n\n\n\n\n\n\n\nExercise 1\n\n\n\nWhat is the name of the new assay added for normalized counts?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Have a look at the assays\nspe@assays\n\nAn object of class \"SimpleAssays\"\nSlot \"data\":\nList of length 2\nnames(2): counts logcounts\n\n# Directly get the assay names(x)\nassayNames(spe)\n\n[1] \"counts\"    \"logcounts\"\n\n\n\n\n\nAfter log-normalization, we can inspect the computed size factors. Size factors are used to account for differences in sequencing depth between spots.\n\n# Display a summary of the calculated size factors.\nsummary(sizeFactors(spe))\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n 0.1179  0.5081  0.7626  1.0000  1.2766  4.9097 \n\n# Visualise the spatial distribution of size factors on the tissue slide.\ncolData(spe)$sizeFactors &lt;- sizeFactors(spe)\nplotVisium(spe, annotate = \"sizeFactors\", zoom = TRUE, point_shape = 22)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nDo you observe any spatial patterns or gradients for the size factors across the tissue section? What do you think they reflect?\n\n\nBonus: accounting for compositional biases\nThe scuttle::computePooledFactors() implements the strategy introduced by Lun et al. to account for compositional biases (which can introduce spurious differences between cells) during normalization.\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nlib.sf.spe &lt;- sizeFactors(spe) ## Store size factors calculated above\nset.seed(100)\nclusters &lt;- quickCluster(spe)\nspe &lt;- computeSumFactors(spe, cluster=clusters, min.mean=0.1)\nspe &lt;- logNormCounts(spe)\n\nplot(lib.sf.spe, sizeFactors(spe), xlab=\"Library size factor\",\n    ylab=\"Deconvolution size factor\", log='xy', pch=16,\n    col=as.integer(factor(clusters)))\nabline(a=0, b=1, col=\"red\")\n\n\n\n\nBonus: spatially-aware normalization\nWhile logNormCounts provides a general-purpose normalization, specialized spatially-aware normalization methods exist. These methods aim to correct for technical variations while preserving true spatial biological patterns. Depending on the dataset and research question, exploring such advanced normalization techniques might be beneficial.\nIf time is left at the end of this practical, explore the normalization strategy implemented in the SpaNorm package."
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#feature-selection",
    "href": "day1/day1-3_feature_dimred_cluster.html#feature-selection",
    "title": "Exercise 3",
    "section": "Feature Selection",
    "text": "Feature Selection\nHighly Variable Genes (HVGs)\nSimilar to scRNA-seq analysis, feature selection is a crucial step to focus on genes that show significant biological variation across spots, and thus increase the signal to noise ratio. We typically aim at focusing on “Highly Variable Genes” (HVGs) as these are more likely to distinguish different cell types or spatial domains.\nIn order to identify HVGs, we will first model the gene variance using a Poisson noise model with scran::modelGeneVarByPoisson()\n\n# Model gene variance to identify highly variable genes.\n# This function fits a mean-variance trend to the log-normalized counts.\ndec &lt;- modelGeneVarByPoisson(spe)\n## Sort by biological variance\ndec &lt;- dec[order(dec$bio, decreasing = T), ]\n\n# Visualize the mean-variance relationship and the fitted trend.\n# This plot helps to understand how gene variability changes with expression level.\nplot(dec$mean, dec$total,\n  xlab = \"Mean expression (log-counts)\",\n  ylab = \"Total variance (log-counts)\",\n  main = \"Mean-Variance Trend\"\n)\ncurve(metadata(dec)$trend(x), add = TRUE, col = \"dodgerblue\", lwd = 2)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 3\n\n\n\nHow do you interpret this plot, compared to similar ones generated from scRNA-seq datasets?\n\n\nOnce we have modeled the gene variance, we can proceed to select the top HVGs. For demonstration purposes, we will visualize the expression patterns of the top 6 HVGs on the tissue slide. We exclude the mitochondrial genes, since those genes tend to be highly variable but do not provide much information about cell types or spatial domains.\n\n# identify mitochondrial genes\nis.mito &lt;- rownames(spe)[grepl(\"^MT-\", rownames(spe))]\n\n# Top 6 HVGs\ntop_HVG &lt;- row.names(dec[!row.names(dec) %in% is.mito, ])[1:6]\ntop_HVG\n\n[1] \"IGKC\"   \"OLFM4\"  \"IGHG1\"  \"COL3A1\" \"PIGR\"   \"COL1A1\"\n\n# Create a plot for each gene in top_HVG\nps &lt;- lapply(top_HVG, \\(.) {\n    plotCoords(spe, \n        annotate = ., \n        assay_name = \"logcounts\") }) # use \"logcounts\" assay to visualise log normalised counts\n\n# figure arrangement and change colors\npatchwork::wrap_plots(ps, nrow = 2) & \n  theme(legend.key.width = unit(0.4, \"lines\"), \n        legend.key.height = unit(0.8, \"lines\")) & \n  scale_color_gradientn(colors = rev(hcl.colors(9, \"Rocket\")))\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nHow would you define the spatial expression patterns of these genes? Look a bit for some information on these genes (e.g., on the Uniprot website) to get a hint at which cell types and domains they could highlight.\n\n\nFor downstream analysis, we define a larger group of HVG and add the information of whether a genes is in the HVG list or not in a rowData slot:\n\n# Select the top 1000 highly variable genes.\nhvg &lt;- getTopHVGs(dec, n = 1000) \n\n# Store HVG information in rowData\nrowData(spe)$hvg &lt;- rowData(spe)$Symbol %in% hvg\n\n# Display the range of biological variation for the selected HVGs\ndec[hvg, ]$bio |&gt; summary()\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n0.01648 0.02117 0.02937 0.08625 0.05359 4.55103 \n\n# Have a look a the new column added\nrowData(spe)\n\nDataFrame with 17952 rows and 5 columns\n                     ID      Symbol            Type subsets_Mito       hvg\n            &lt;character&gt; &lt;character&gt;        &lt;factor&gt;    &lt;logical&gt; &lt;logical&gt;\nSAMD11  ENSG00000187634      SAMD11 Gene Expression        FALSE     FALSE\nNOC2L   ENSG00000188976       NOC2L Gene Expression        FALSE     FALSE\nKLHL17  ENSG00000187961      KLHL17 Gene Expression        FALSE     FALSE\nPLEKHN1 ENSG00000187583     PLEKHN1 Gene Expression        FALSE     FALSE\nPERM1   ENSG00000187642       PERM1 Gene Expression        FALSE     FALSE\n...                 ...         ...             ...          ...       ...\nMT-ND4L ENSG00000212907     MT-ND4L Gene Expression         TRUE      TRUE\nMT-ND4  ENSG00000198886      MT-ND4 Gene Expression         TRUE      TRUE\nMT-ND5  ENSG00000198786      MT-ND5 Gene Expression         TRUE      TRUE\nMT-ND6  ENSG00000198695      MT-ND6 Gene Expression         TRUE      TRUE\nMT-CYB  ENSG00000198727      MT-CYB Gene Expression         TRUE      TRUE\n\n\nSpatially Variable Genes (SVGs)\nWe will go very quickly over this topic, which will be discussed in depth tomorrow. Today, the idea is to get an intuition about the difference between HVGs and SVGs. For this, we select randomly 6 other HVGs from the list, and plot their expression:\n\n# Select randomly 6 HVGs\nset.seed(123)\nrandom_HVG &lt;- sample(row.names(dec), size = 6)\n\n# Create a plot for each gene in top_HVG\nps &lt;- lapply(random_HVG, \\(.) {\n    plotCoords(spe, \n        annotate = ., \n        assay_name = \"logcounts\") }) # use \"logcounts\" assay to visualise log normalised counts\n\n# figure arrangement and change colors\npatchwork::wrap_plots(ps, nrow = 2) & \n  theme(legend.key.width = unit(0.4, \"lines\"), \n        legend.key.height = unit(0.8, \"lines\")) & \n  scale_color_gradientn(colors = rev(hcl.colors(9, \"Rocket\")))\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 5\n\n\n\nHow would you define the spatial expression patterns of these genes? What is the difference with genes at the top of the list? Which ones would you qualify as SVGs?"
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#dimensionality-reduction-dr",
    "href": "day1/day1-3_feature_dimred_cluster.html#dimensionality-reduction-dr",
    "title": "Exercise 3",
    "section": "Dimensionality Reduction (DR)",
    "text": "Dimensionality Reduction (DR)\nThereafter we make use of the highly variable genes (HVGs) to perform dimensionality reduction and clustering.\nNon-spatially aware DR:\nPCA\nWe can perform dimensionality reduction using Principal Component Analysis (PCA) on the log-normalized expression values of the HVGs. This method is agnostic to spatial information, and focuses solely on capturing the main axes of variation in the gene expression data.\n\n# Run PCA on the log-normalized counts of the HVGs\nspe &lt;- runPCA(spe, ncomponents = 30, subset_row = rowData(spe)$hvg)\n\n# Visualize the explained variance by each principal component.\n# This helps in determining how many PCs capture most of the variance.\nplot(attr(reducedDim(spe, \"PCA\"), \"percentVar\"),\n  xlab = \"PC\", ylab = \"Proportion of variance explained\",\n  main = \"PCA Scree Plot\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 6\n\n\n\nBased on the scree plot, how many principal components would you consider for downstream analysis? Why? You can also have look at the scran::getDenoisedPCs function to help you make this choice.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe can select the first 10 PCs for downstream analysis, as they seem to capture a significant proportion of the variance in the data before the explained variance starts to level off.\n\n\n\nChoose the number of PCs accordingly for downstream analysis. Visualize the PCs on the tissue slice coordinates.\n\n# Run PCA on the log-normalized counts of the HVGs using the top PCs, for example 10 PCs\nspe &lt;- runPCA(spe, ncomponents = 10, subset_row = rowData(spe)$hvg)\n\n# Get the PCA results \npcs &lt;- reducedDim(spe, \"PCA\")\n# Visualize PCs on the tissue slice coordinates\nps &lt;- lapply(colnames(pcs), \\(.) {\n    spe[[.]] &lt;- pcs[, .]\n    plotCoords(spe, annotate = .)\n}) \n# Arrange the plots and customize colors\npatchwork::wrap_plots(ps, nrow = 2) & \n  theme(legend.key.width = unit(0.4, \"lines\"), \n        legend.key.height = unit(0.8, \"lines\")) & \n  scale_color_gradientn(colors = rev(hcl.colors(9, \"Rocket\")))\n\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 7\n\n\n\nWhat do you notice? How do you interpret it?\nBonus Exercise\nExtract the genes most associated with one of these PCs\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe observe a strong correlation between the PCs scores and the expression patterns observed above for the top HVGs, suggesting that they refelct cell type or domain biology.\nTo extract the 10 genes most associated to PC2:\n\nattributes(reducedDims(spe)[[\"PCA\"]])$rotation[, \"PC2\"] |&gt; abs() |&gt; sort(decreasing = TRUE) |&gt; names() |&gt; head(n=10)\n\n [1] \"COL3A1\" \"COL1A1\" \"COL1A2\" \"CXCR4\"  \"CD74\"   \"IGKC\"   \"MMP2\"   \"TXNIP\" \n [9] \"A2M\"    \"SPARC\" \n\n\nSpatially aware DR:\nBanksy\nWe can also perform spatially aware dimensionality reduction using the Banksy method, which integrates spatial coordinates and gene expression into the PCA framework. This allows us to capture spatial patterns in the data while reducing dimensionality.\n\n# 'Banksy' parameter settings\nk &lt;- 20   # consider first order neighbors\nl &lt;- 0.8 # use spatial information with weight lambda\na &lt;- \"logcounts\" # assay to use\nxy &lt;- c(\"array_row\", \"array_col\")  # spatial coordinate names\n\n# compute spatially aware 'Banksy' PCs, using the HVGs only\nset.seed(112358)\ntmp &lt;- computeBanksy(spe[rowData(spe)$hvg, ], \n                     assay_name=a, \n                     coord_names=xy, \n                     k_geom=k, \n                     parallel=T,\n                     num_cores=4)\ntmp &lt;- runBanksyPCA(tmp, \n                    lambda=l, \n                    npcs=10)\nreducedDim(spe, \"PCA_banksy\") &lt;- reducedDim(tmp) # store 'Banksy' PCs in original object\n\n\n\n\n\n\n\nExercise 8\n\n\n\nWhile this is running, have a look at the Banksy paper to understand better what the method is doing.\nHave a look at the spe object to see the dimensionality reduction slots. How many dimensionality reductions are stored now? What are their names and what do they represent?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nspe\n\nclass: SpatialExperiment \ndim: 17952 12615 \nmetadata(2): resources spatialList\nassays(2): counts logcounts\nrownames(17952): SAMD11 NOC2L ... MT-ND6 MT-CYB\nrowData names(5): ID Symbol Type subsets_Mito hvg\ncolnames(12615): s_016um_00144_00175-1 s_016um_00204_00145-1 ...\n  s_016um_00193_00227-1 s_016um_00109_00223-1\ncolData names(36): barcode in_tissue ... sizeFactor sizeFactors\nreducedDimNames(3): PCA_artifacts PCA PCA_banksy\nmainExpName: Gene Expression\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\nreducedDimNames(spe)\n\n[1] \"PCA_artifacts\" \"PCA\"           \"PCA_banksy\"   \n\n\nThere are now three dimensionality reductions stored in the spe object: :“PCA_artifacts”, “PCA” and “PCA_banksy”. “PCA_artifacts” was computed to capture technical artifacts in a previous exercise (QC step).\n“PCA” represents the non-spatially aware principal components, while “PCA_banksy” represents the spatially aware principal components computed using the Banksy method. Both methods have used HVGs for dimensionality reduction.\n\n\n\nIn the same way as before, we can visualise the Banksy PCs on the tissue slice coordinates.\n\n\n\n\n\n\nExercise 9\n\n\n\nSelect PCs from Banksy dimensionality reduction space and visualise them on the tissue slice. Do you observe any spatial patterns? How do they compare to the non-spatial PCs?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n## Visualize PCs on the tissue slice coordinates\npcs &lt;- reducedDim(spe, \"PCA_banksy\")\nps &lt;- lapply(colnames(pcs), \\(.) {\n    spe[[.]] &lt;- pcs[, .]\n    plotCoords(spe, annotate = .)\n}) \npatchwork::wrap_plots(ps, nrow = 2) & \n  theme(legend.key.width = unit(0.4, \"lines\"), \n        legend.key.height = unit(0.8, \"lines\")) & \n  scale_color_gradientn(colors = rev(hcl.colors(9, \"Rocket\")))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBonus Exercise\n\n\n\nTry to change Banksy parameters k and lambda. How does it affect the results?\n\n\nRun UMAP\nFor visualization purposes only, we’ll produce UMAPs based on on both spatially aware and not spatially aware PCA results:\n\n# UMAP\nspe &lt;- runUMAP(spe, dimred=\"PCA\", name=\"UMAP_tx\")\nspe &lt;- runUMAP(spe, dimred=\"PCA_banksy\", name=\"UMAP_banksy\")\n\n\n# Visualise\nplotReducedDim(spe, dimred = \"UMAP_tx\", colour_by = \"detected\") + \n  scale_colour_gradient(trans = \"log\", high = \"yellow\", low = \"red\")\n\n\n\n\n\n\nplotReducedDim(spe, dimred = \"UMAP_banksy\", colour_by = \"detected\") +\n    scale_colour_gradient(trans = \"log\", high = \"yellow\", low = \"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nBonus question\n\n\n\nIf you tried different parameters for Banksy, how does it affect the UMAP results?\n\n\nSave data for later\n\nspe_HVG &lt;- spe\nsaveHDF5SummarizedExperiment(spe_HVG, dir=\"results/day1\", prefix=\"01.3_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)"
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#bonus-exercise",
    "href": "day1/day1-3_feature_dimred_cluster.html#bonus-exercise",
    "title": "Exercise 3",
    "section": "Bonus Exercise",
    "text": "Bonus Exercise\nExtract the genes most associated with one of these PCs"
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#run-umap",
    "href": "day1/day1-3_feature_dimred_cluster.html#run-umap",
    "title": "Exercise 3",
    "section": "Run UMAP",
    "text": "Run UMAP\nFor visualization purposes only, we’ll produce UMAPs based on on both spatially aware and not spatially aware PCA results:\n\n# UMAP\nspe &lt;- runUMAP(spe, dimred=\"PCA\", name=\"UMAP_tx\")\nspe &lt;- runUMAP(spe, dimred=\"PCA_banksy\", name=\"UMAP_banksy\")\n\n\n# Visualise\nplotReducedDim(spe, dimred = \"UMAP_tx\", colour_by = \"detected\") + \n  scale_colour_gradient(trans = \"log\", high = \"yellow\", low = \"red\")\n\n\n\n\n\n\nplotReducedDim(spe, dimred = \"UMAP_banksy\", colour_by = \"detected\") +\n    scale_colour_gradient(trans = \"log\", high = \"yellow\", low = \"red\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nBonus question\n\n\n\nIf you tried different parameters for Banksy, how does it affect the UMAP results?"
  },
  {
    "objectID": "day1/day1-3_feature_dimred_cluster.html#save-data-for-later",
    "href": "day1/day1-3_feature_dimred_cluster.html#save-data-for-later",
    "title": "Exercise 3",
    "section": "Save data for later",
    "text": "Save data for later\n\nspe_HVG &lt;- spe\nsaveHDF5SummarizedExperiment(spe_HVG, dir=\"results/day1\", prefix=\"01.3_spe\", replace=TRUE,\n                                chunkdim=NULL, level=NULL, as.sparse=NA,\n                                verbose=NA)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html",
    "href": "day2/day2-1_spatial_stats.html",
    "title": "Exercise 1",
    "section": "",
    "text": "Learn the basic principles of exploratory spatial statistics\nCompute and visualise local and global measures of spatial autocorrelation\nCompare spatial statistics measures across samples using linear mixed models\nThis chapter is based on the OSTA online book chapter on spatial statistics and uses heavily the Voyager spatial statistics library (Moses et al. 2023)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#learning-objectives",
    "href": "day2/day2-1_spatial_stats.html#learning-objectives",
    "title": "Exercise 1",
    "section": "",
    "text": "Learn the basic principles of exploratory spatial statistics\nCompute and visualise local and global measures of spatial autocorrelation\nCompare spatial statistics measures across samples using linear mixed models\nThis chapter is based on the OSTA online book chapter on spatial statistics and uses heavily the Voyager spatial statistics library (Moses et al. 2023)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#libraries",
    "href": "day2/day2-1_spatial_stats.html#libraries",
    "title": "Exercise 1",
    "section": "Libraries",
    "text": "Libraries\n\nlibrary(\"SpatialExperiment\")\nlibrary(\"ggplot2\")\nlibrary(\"Voyager\")\nlibrary(\"HDF5Array\")\nlibrary(\"tidyr\")\nlibrary(\"dplyr\")\nlibrary(\"lme4\")\nlibrary(\"lmerTest\")\nset.seed(1234)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#load-data",
    "href": "day2/day2-1_spatial_stats.html#load-data",
    "title": "Exercise 1",
    "section": "Load data",
    "text": "Load data\n\n# Load the SpatialExperiment objectq\nspe &lt;- loadHDF5SummarizedExperiment(dir=\"results/day1\", prefix=\"01.1_spe\")\n\nIn order to use the big spatial statistics library sf we convert the SpatialExperiment object into a SpatialFeatureExperiment object (Moses et al. 2025). In addition to the SpatialExperiment object it contains simple feature categories such as Geometries and Graphs. In this 10x Visium Dataset the Geometries stored are the coordinates of the spots\n\nsfe &lt;- toSpatialFeatureExperiment(spe)\nsfe\n\nclass: SpatialFeatureExperiment \ndim: 18085 14207 \nmetadata(2): resources spatialList\nassays(1): counts\nrownames(18085): SAMD11 NOC2L ... MT-ND6 MT-CYB\nrowData names(3): ID Symbol Type\ncolnames(14207): s_016um_00144_00175-1 s_016um_00204_00145-1 ...\n  s_016um_00193_00227-1 s_016um_00109_00223-1\ncolData names(6): barcode in_tissue ... bin_size sample_id\nreducedDimNames(0):\nmainExpName: Gene Expression\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nsample01:"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#data-modalities-of-spatial-statistics",
    "href": "day2/day2-1_spatial_stats.html#data-modalities-of-spatial-statistics",
    "title": "Exercise 1",
    "section": "Data modalities of spatial statistics",
    "text": "Data modalities of spatial statistics\nIn spatial transcriptomics we differentiate between imaging-based and sequencing-based technologies which give rise to very different data modalities (Rao et al. 2021).\n\n\nData Modalities in Spatial Transcriptomics (Emons et al. 2025)\n\nOur dataset was acquired using 10x Visium HD. The data modality of this technology is best described by a regular lattice. This means that the observations are taken at regularly spaced intervals. This is very different to imaging-based approaches where observations are due to a stochastic data generating process, which is related to some underlying biological mechanism.\nWith spots of 2um^2, Visium HD can provide subcellular resolution. We can segment cells from this regular lattice of pixels and approximate the cells by their centroid. This in turn can be described as an irregular lattice of the cell types in space or even be analysed as a point process of the cell centroid locations.\nIn what follows we will focus on analysing the regular lattice of the pixel measurements with techniques from lattice data analysis."
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#preprocessing-and-neighbourhood-defintion",
    "href": "day2/day2-1_spatial_stats.html#preprocessing-and-neighbourhood-defintion",
    "title": "Exercise 1",
    "section": "Preprocessing and neighbourhood defintion",
    "text": "Preprocessing and neighbourhood defintion\nWe note that the counts in our SpatialFeatureExperiment object are still raw counts therefore we will log normalise them with scuttle::logNormCounts()\n\n# identify mitochondrial genes\ngn &lt;- rowData(sfe)$Symbol\nmt &lt;- grepl(\"^MT-\", gn, ignore.case = TRUE)\ntable(mt)\n\nmt\nFALSE  TRUE \n18074    11 \n\n# remove them\nsfe &lt;- sfe[!mt, ]\n\n#log-normalise the counts\nsfe &lt;- scuttle::logNormCounts(sfe)\nsfe\n\nclass: SpatialFeatureExperiment \ndim: 18074 14207 \nmetadata(2): resources spatialList\nassays(2): counts logcounts\nrownames(18074): SAMD11 NOC2L ... EIF1AY DAZ2\nrowData names(3): ID Symbol Type\ncolnames(14207): s_016um_00144_00175-1 s_016um_00204_00145-1 ...\n  s_016um_00193_00227-1 s_016um_00109_00223-1\ncolData names(7): barcode in_tissue ... sample_id sizeFactor\nreducedDimNames(0):\nmainExpName: Gene Expression\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nsample01: \n\n\nNow, we notice a logcounts assay in our object.\nNext, we will define a neighbourhood on which we want to compute spatial statistics metrics. In 10x Visium it is very natural to consider the direct neigbours of hexagonal visium lattice. We do this with the function Voyager::findVisiumGraph().\n\ncolGraph(sfe, \"visium\") &lt;- findVisiumGraph(sfe)\ncolGraph(sfe, \"binary\") &lt;- findVisiumGraph(sfe, style = \"B\")\n\nplotColGraph(sfe,\n  colGraphName = \"visium\"\n) + theme_void()\n\n\n\n\n\n\n\nWe notice two things:\n\nThe \\(y\\)-coordinate is flipped compared to the image. This is due to the way that visium data is acquired. The Visium slide is placed on top of the tissue but the H&E image is acquired from below the tissue.\nOn top of the spots we know see the hexagonal neighbourhood on top of the regular lattice."
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#global-indicators-of-spatial-association",
    "href": "day2/day2-1_spatial_stats.html#global-indicators-of-spatial-association",
    "title": "Exercise 1",
    "section": "Global indicators of spatial association",
    "text": "Global indicators of spatial association\nNow that we have defined both the neighbourhood of a spot and preprocessed the gene expression, we can turn to measures of spatial association.\nIn general, in a global association metric we compute for each point \\(i\\) a metric for its neighbourhood \\(j\\). The neighbourhood we quantified before as the regular hexagonal grid and is passed to the functions as a weight matrix \\(w_{ij}\\). The association measure is then a function \\(f(x_i,x_j)\\) and could e.g. quantify spatial correlation\n\\[\n\\sum_i \\sum_j f(x_i,x_j) w_{ij}\n\\]\nA very famous measure of global spatial autocorrelation is called Moran’s \\(I\\). It assess correlation of a gene with itself given a defined weight matrix \\(w\\) (Moran 1950).\n\n\n\n\n\n\nExercise\n\n\n\n\nModel the variance of the log-transformed expression profiles per gene with scran::modelGeneVar() (using the argument subset.row will make the fitting faster)\nExtract the top 200 highly variable genes in this dataset with scran::getTopHVGs()\n\nCalculate the global Moran’s \\(I\\) coefficient with the function Voyager::runUnivariate() on these 200 highly variable genes. You can find information and examples on how to run this function by typing ?runUnivariate in your console\nExtract the top 3 genes with the highest Moran’s \\(I\\) value\nPlot the expression of these three genes in space using Voyager::plotSpatialFeature\n\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFirst, we model the variance on a subset of the genes for computational reasons Then, we extract the 200 most highly variable genes\n\nstats &lt;- scran::modelGeneVar(sfe, subset.row = 1:2000)\nhvg &lt;- scran::getTopHVGs(stats, n = 200)\n\nNext, we calculate global Moran’s I for these 200 genes\n\nsfe &lt;- runUnivariate(sfe, \n    type=\"moran\", \n    features=hvg, \n    colGraphName=\"visium\")\n\nWe order them and plot the gene expression top 3 genes wiht the plotSpatialFeature function from the Voyager package.\n\nI &lt;- rowData(sfe)$moran_sample01\no &lt;- order(I, decreasing=TRUE)\ntopGenes &lt;- rownames(sfe)[head(o, 3)]\nplotSpatialFeature(sfe, topGenes, ncol=3)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#local-indicators-of-spatial-association",
    "href": "day2/day2-1_spatial_stats.html#local-indicators-of-spatial-association",
    "title": "Exercise 1",
    "section": "Local indicators of spatial association",
    "text": "Local indicators of spatial association\nIn the section above, we have computed a global measure of spatial association, meaning that we get one number per field-of-view. This is an average of the local contributions and neglects the potential underlying heterogeneity completely.\nTherefore, we will investigate local indicators of spatial association (Anselin 1995).\nIn the case of Moran’s \\(I\\) we will now not calculate one measure for the entire field-of-view but rather one metric per location/spot \\(i\\): \\(I_i\\).\n\n\n\n\n\n\nExercise\n\n\n\n\nCalculate local Moran’s \\(I\\) for the top three global Moran’s \\(I\\) genes from above using the function Voyager::runUnivariate()\nPlot the local Moran’s \\(I\\) values in space using Voyager::plotLocalResult\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFirst, we have to calculate the metric on the first most autocorrelated genes.\n\nsfe &lt;- runUnivariate(sfe,\n                     features = topGenes,\n                     colGraphName = \"visium\",\n                     type = \"localmoran\")\n\nThen, we plot the local Moran’s \\(I\\) values in space.\n\nplotLocalResult(sfe, \"localmoran\",\n                features =topGenes, ncol = 3,\n                colGeometryName = \"centroids\",\n                divergent = TRUE, diverge_center = 0)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#discretising-regions-with-morans-scatterplot",
    "href": "day2/day2-1_spatial_stats.html#discretising-regions-with-morans-scatterplot",
    "title": "Exercise 1",
    "section": "Discretising regions with Moran’s scatterplot",
    "text": "Discretising regions with Moran’s scatterplot\nThe continuous local Moran’s \\(I_i\\) measurements can be difficult to interpret. A simplification is Moran’s scatter plot (Anselin 2019). The idea is to compare the Moran’s \\(I\\) of the spot \\(i\\) itself with its neighbours \\(j\\). Like this we obtain four options: high \\(I_i\\) next to neighbours that have high \\(I_j\\), high \\(I_i\\) next to neighbours that have low \\(I_j\\) etc. This separates outliers (high-low and low-high) from values within more homogeneous regions (high-high and low-low).\n\n\n\n\n\n\nBonus Exercise\n\n\n\n\nCalculate Moran’s scatterplot with runUnivariate on the top three global Moran’s \\(I\\) genes from above\nPlot the Moran’s scatterplot results in space using Voyager::plotLocalResult\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFirst, we have to calculate the metric on the first three most variable hvgs.\n\nsfe &lt;- runUnivariate(\n    sfe,\n    features =  topGenes,\n    colGraphName = \"visium\",\n    type = \"moran.plot\"\n  )\n\nWe will show the Moran’s scatter plot for the gene PIGR.\n\n# we will show one Moran's scatterplot\nmoranPlot(sfe, topGenes[1], graphName = \"visium\", swap_rownames = \"symbol\") + theme_classic()\n\n\n\n\n\n\n\nThe grey dashed lines indicate the mean expreession of the “PIGR” expression in the spots themselves and among their neighbours. According to to these means the spots are categorised into 4 categories, which can be plotted back in space. We notice that there is quite a large fraction of regions that constitute as “high-high” for all the genes in the same region.\n\nplotLocalResult(\n    sfe,\n    name = \"localmoran\",\n    features = topGenes,\n    attribute = \"mean\",\n    colGeometryName = \"centroids\"\n)"
  },
  {
    "objectID": "day2/day2-1_spatial_stats.html#preprocessing-and-neighbourhood-defintion-1",
    "href": "day2/day2-1_spatial_stats.html#preprocessing-and-neighbourhood-defintion-1",
    "title": "Exercise 1",
    "section": "Preprocessing and neighbourhood defintion",
    "text": "Preprocessing and neighbourhood defintion\nWe note that the counts in our SpatialFeatureExperiment object are still raw counts therefore we will log normalise them with scuttle::logNormCounts()\n\n# identify mitochondrial genes\ngn &lt;- rowData(sfeMult)$Symbol\nmt &lt;- grepl(\"^MT-\", gn, ignore.case = TRUE)\ntable(mt)\n\nmt\nFALSE  TRUE \n18034    11 \n\n# remove them\nsfeMult &lt;- sfeMult[!mt, ]\n\n#log-normalise the counts\nsfeMult &lt;- scuttle::logNormCounts(sfeMult)\nsfeMult\n\nclass: SpatialFeatureExperiment \ndim: 18034 56120 \nmetadata(0):\nassays(2): counts logcounts\nrownames(18034): SAMD11 NOC2L ... KDM5D EIF1AY\nrowData names(3): ID Symbol Type\ncolnames(56120): s_016um_00145_00029-1.Normal_P5\n  s_016um_00165_00109-1.Normal_P5 ... s_016um_00122_00096-1.Normal_P3\n  s_016um_00127_00062-1.Normal_P3\ncolData names(8): row col ... array_col sizeFactor\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(1): sample_id\n\nunit:\nGeometries:\ncolGeometries: centroids (POINT) \n\nGraphs:\nNormal_P5: \nCancer_P5: \nCancer_P1: \nNormal_P3: \n\n\nNow, we notice a logcounts assay in our object.\nNext, we will define a neighbourhood on which we want to compute spatial statistics metrics. For computational reasons we will consider a \\(k\\) nearest neighbourhood around the cells.\n\nallGraphs &lt;- findSpatialNeighbors(sfeMult,\n    method = \"knearneigh\", # wraps the spdep function with the same name\n    k = 5,\n    zero.policy = TRUE,\n    sample_id = \"all\"\n  )\n\ncolGraphs(sfeMult, \"knn5\", sample_id = \"all\") &lt;- allGraphs\n\n\n\n\n\n\n\nQuestion\n\n\n\n\nGiven you have now a SpatialFeatureExperiment object with four samples, how would you compare a global indicator of spatial association across conditions, possibly with multiple samples? As an example, calculate global univariate Moran’s \\(I\\) for the gene “PIGR”.\nan important flag in this question is sample_id = \"all\". For reasons of having isolated cell patches, consider a \\(k\\)-NN neighbourhood this time instead of findVisiumGraph.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFirst, we need to calculate univariate Moran’s \\(I\\) for all samples\n\nsfeMult &lt;- runUnivariate(sfeMult,\n                     features = \"PIGR\",\n                     colGraphName = \"knn5\",\n                     exprs_values = \"logcounts\",\n                     sample_id = \"all\",\n                     type = \"moran.mc\",\n                     nsim = 200)\n\n\nres &lt;- rowData(sfeMult)[\"PIGR\",]\nres\n\nDataFrame with 1 row and 27 columns\n                  ID      Symbol            Type moran.mc_statistic_Normal_P5\n         &lt;character&gt; &lt;character&gt;        &lt;factor&gt;                    &lt;numeric&gt;\nPIGR ENSG00000162896        PIGR Gene Expression                     0.665933\n     moran.mc_parameter_Normal_P5 moran.mc_p.value_Normal_P5\n                        &lt;numeric&gt;                  &lt;numeric&gt;\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Normal_P5 moran.mc_method_Normal_P5\n                        &lt;character&gt;               &lt;character&gt;\nPIGR                        greater    Monte-Carlo simulati..\n                   moran.mc_res_Normal_P5 moran.mc_statistic_Cancer_P5\n                                   &lt;list&gt;                    &lt;numeric&gt;\nPIGR 0.00364546,0.00024356,0.00120214,...                     0.662601\n     moran.mc_parameter_Cancer_P5 moran.mc_p.value_Cancer_P5\n                        &lt;numeric&gt;                  &lt;numeric&gt;\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Cancer_P5 moran.mc_method_Cancer_P5\n                        &lt;character&gt;               &lt;character&gt;\nPIGR                        greater    Monte-Carlo simulati..\n                      moran.mc_res_Cancer_P5 moran.mc_statistic_Cancer_P1\n                                      &lt;list&gt;                    &lt;numeric&gt;\nPIGR -0.00521515,-0.00276429, 0.01003306,...                     0.839516\n     moran.mc_parameter_Cancer_P1 moran.mc_p.value_Cancer_P1\n                        &lt;numeric&gt;                  &lt;numeric&gt;\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Cancer_P1 moran.mc_method_Cancer_P1\n                        &lt;character&gt;               &lt;character&gt;\nPIGR                        greater    Monte-Carlo simulati..\n                      moran.mc_res_Cancer_P1 moran.mc_statistic_Normal_P3\n                                      &lt;list&gt;                    &lt;numeric&gt;\nPIGR -0.00500185, 0.00928462, 0.00367372,...                     0.554004\n     moran.mc_parameter_Normal_P3 moran.mc_p.value_Normal_P3\n                        &lt;numeric&gt;                  &lt;numeric&gt;\nPIGR                          201                 0.00497512\n     moran.mc_alternative_Normal_P3 moran.mc_method_Normal_P3\n                        &lt;character&gt;               &lt;character&gt;\nPIGR                        greater    Monte-Carlo simulati..\n                      moran.mc_res_Normal_P3\n                                      &lt;list&gt;\nPIGR -0.00188827,-0.00658297, 0.00488671,...\n\n\nIn order to model these measures, we have to convert the data into long format\n\ndf_long &lt;- res |&gt; as.data.frame() |&gt;\n  tibble::rownames_to_column(\"gene\") |&gt;\n  pivot_longer(\n    cols = starts_with(\"moran.mc_statistic\"),\n    names_to = c(\"measure\", \"sample\"),\n    names_pattern = \"(.*)statistic_(.*)\",\n    values_to = \"morans\"\n  ) |&gt; separate(sample, into = c(\"condition\", \"replicate\"), sep = \"_\") |&gt; \n  select(c( \"gene\", \"condition\",  \"replicate\", \"measure\", \"morans\"))\n\ndf_long\n\n# A tibble: 4 × 5\n  gene  condition replicate measure   morans\n  &lt;chr&gt; &lt;chr&gt;     &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;\n1 PIGR  Normal    P5        moran.mc_  0.666\n2 PIGR  Cancer    P5        moran.mc_  0.663\n3 PIGR  Cancer    P1        moran.mc_  0.840\n4 PIGR  Normal    P3        moran.mc_  0.554\n\n\n\ntable(df_long$condition, df_long$replicate)\n\n        \n         P1 P3 P5\n  Cancer  1  0  1\n  Normal  0  1  1\n\n\nWe see that we have a nested variance structure in this data. We have two conditions “Normal” and “Cancer”. We note that the patient identifiers are not unique, meaning that we have some samples from the same patient.\nIn order to account for this dependence, we have to model the data with a mixed-effects model. One option is the lme4 package in R.\n\n#convert condition to a factor and relevel to have Normal as comparison group\ndf_long$condition &lt;- as.factor(df_long$condition) |&gt;\n  relevel(ref = \"Normal\")\nmdl &lt;- lmer(morans ~ condition + (1|replicate), data = df_long)\n\nboundary (singular) fit: see help('isSingular')\n\nsummary(mdl)\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: morans ~ condition + (1 | replicate)\n   Data: df_long\n\nREML criterion at convergence: -2\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-0.8451 -0.6123  0.0000  0.6123  0.8451 \n\nRandom effects:\n Groups    Name        Variance Std.Dev.\n replicate (Intercept) 0.00000  0.0000  \n Residual              0.01096  0.1047  \nNumber of obs: 4, groups:  replicate, 3\n\nFixed effects:\n                Estimate Std. Error      df t value Pr(&gt;|t|)  \n(Intercept)      0.60997    0.07402 2.00000   8.241   0.0144 *\nconditionCancer  0.14109    0.10467 2.00000   1.348   0.3101  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n            (Intr)\nconditnCncr -0.707\noptimizer (nloptwrap) convergence code: 0 (OK)\nboundary (singular) fit: see help('isSingular')\n\n\nWe note that in this example there is no difference in the global Moran’s \\(I\\) value for the gene “PIGR”. This not surprising since a model with 3 independent samples is strongly under-powered.\nAn important step in interpreting a statistical model is looking at some model diagnostics. We will plot the qq plot of this mixed effects model. We note that the four samples follow the theoretical line well. But we notice again, that having only four samples is a great limitation of this dataset.\n\nqqnorm(resid(mdl), pch = 16)\nqqline(resid(mdl))"
  },
  {
    "objectID": "day2/day2-3_differential_spatial_pattern.html",
    "href": "day2/day2-3_differential_spatial_pattern.html",
    "title": "Exercise 3",
    "section": "",
    "text": "In this exercise, we extend our analysis to multi-sample, multi-condition spatial transcriptomics data. With multiple samples per condition (e.g., 2 colorectal carcinoma (CRC) and 2 normal adjacent tissues), we can ask not only:\n\n“Is a gene spatially variable within a tissue?”\n\nbut also:\n\n“Does its spatial pattern change between conditions?”\n\nGenes showing such changes are called differential spatial patterns (DSP) genes. Using the DESpace package, we will learn how to identify such genes, that may be spatially variable in one condition but not in another, or it could be spatially variable in both conditions, but with different spatial patterns."
  },
  {
    "objectID": "day2/day2-3_differential_spatial_pattern.html#differential-analysis-with-multi-sample",
    "href": "day2/day2-3_differential_spatial_pattern.html#differential-analysis-with-multi-sample",
    "title": "Exercise 3",
    "section": "",
    "text": "In this exercise, we extend our analysis to multi-sample, multi-condition spatial transcriptomics data. With multiple samples per condition (e.g., 2 colorectal carcinoma (CRC) and 2 normal adjacent tissues), we can ask not only:\n\n“Is a gene spatially variable within a tissue?”\n\nbut also:\n\n“Does its spatial pattern change between conditions?”\n\nGenes showing such changes are called differential spatial patterns (DSP) genes. Using the DESpace package, we will learn how to identify such genes, that may be spatially variable in one condition but not in another, or it could be spatially variable in both conditions, but with different spatial patterns."
  },
  {
    "objectID": "day2/day2-3_differential_spatial_pattern.html#learning-objectives",
    "href": "day2/day2-3_differential_spatial_pattern.html#learning-objectives",
    "title": "Exercise 3",
    "section": "Learning Objectives",
    "text": "Learning Objectives\nBy the end of this exercise, you will be able to:\n\nUnderstand the concept of DSP\nPerform global DSP tests across multiple samples\n\nPerform individual-cluster tests to find cluster-specific DSP genes\n\nInterpret the DSP patterns"
  },
  {
    "objectID": "day2/day2-3_differential_spatial_pattern.html#load-preprocessed-data",
    "href": "day2/day2-3_differential_spatial_pattern.html#load-preprocessed-data",
    "title": "Exercise 3",
    "section": "Load preprocessed data",
    "text": "Load preprocessed data\nWe will work with the same VisiumHD dataset from the human colon cancer study recently published. Here we use a preprocessed dataset containing 4 VisiumHD slides from three patients (P1CRC, P5CRC, P3NAT, and P5NAT), representing either colorectal carcinoma (CRC) or normal adjacent tissues (NAT), all with pre-computed clusters.\n\nspe &lt;- loadHDF5SummarizedExperiment(dir=\"data/\", prefix=\"02.3_spe_tmp\")\nspe &lt;- scuttle::logNormCounts(spe)\nspe\n\nclass: SpatialExperiment \ndim: 18045 56120 \nmetadata(0):\nassays(2): counts logcounts\nrownames(18045): SAMD11 NOC2L ... MT-ND6 MT-CYB\nrowData names(3): ID Symbol Type\ncolnames(56120): s_016um_00145_00029-1.Normal_P5\n  s_016um_00165_00109-1.Normal_P5 ... s_016um_00122_00096-1.Normal_P3\n  s_016um_00127_00062-1.Normal_P3\ncolData names(6): row col ... sample_id sizeFactor\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres\nimgData names(4): sample_id image_id data scaleFactor\n\n\ncolData(spe) includes:\n\n\nsample_id: sample ID\n\ncondition: CRC vs. Normal tissue\n\ncluster: spatial domain labels\n\n\nhead(colData(spe), 3)\n\nDataFrame with 3 rows and 6 columns\n                                      row       col  cluster condition\n                                &lt;integer&gt; &lt;integer&gt; &lt;factor&gt;  &lt;factor&gt;\ns_016um_00145_00029-1.Normal_P5       145        29       3     Normal\ns_016um_00165_00109-1.Normal_P5       165       109       9     Normal\ns_016um_00188_00060-1.Normal_P5       188        60       10    Normal\n                                sample_id sizeFactor\n                                 &lt;factor&gt;  &lt;numeric&gt;\ns_016um_00145_00029-1.Normal_P5 Normal_P5   2.309698\ns_016um_00165_00109-1.Normal_P5 Normal_P5   3.266692\ns_016um_00188_00060-1.Normal_P5 Normal_P5   0.938006\n\ntable(spe$condition)\n\n\nCancer Normal \n 29064  27056 \n\n\nVisualize clusters for each sample.\n\nsamples &lt;- sort(unique(spe$sample_id))\nlapply(samples, \\(.)\n       plotCoords(spe[, spe$sample_id == .],\n                  annotate=\"cluster\",\n                  in_tissue=NULL,\n                  point_size = 0.1) +\n         ggtitle(.)) |&gt;\n  wrap_plots(nrow = 2) &\n  scale_color_manual(values=unname(pals::trubetskoy())) &\n  theme_void() &\n  theme(legend.position = \"none\")\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale."
  },
  {
    "objectID": "day2/day2-3_differential_spatial_pattern.html#despace",
    "href": "day2/day2-3_differential_spatial_pattern.html#despace",
    "title": "Exercise 3",
    "section": "DESpace",
    "text": "DESpace\nGlobal test\nTo answer the question: does the expression of a gene change between conditions, but change differently for some domains compared to others?\nDESpace::dsp_test() first aggregates spot- or cell-level counts into pseudobulk counts for each (sample, domain) combination, then tests whether the interaction term (condition x domain) in the model is different from zero.\n\n# Take few minutes to run\nres_edgeR &lt;- dsp_test(spe,\n                      cluster_col = \"cluster\",\n                      sample_col = \"sample_id\",\n                      condition_col = \"condition\",\n                      filter_gene = TRUE,\n                      verbose = TRUE)\n\nUsing 'dsp_test' for spatial variable pattern genes detection.\n\n\nFilter low quality genes: \n\n\nThe number of genes that pass filtering is 13378.\n\n\nFilter low quality clusters: \n\n\nCluster levels to keep: 0, 2, 3, 4, 5, 6, 8, 9, 10, 11, 13, 14, 16, 17\n\n\nDesign model: row names represent sample names, followed by underscores and cluster names.\n\n\n            (Intercept) conditionNormal cluster_id10 cluster_id11 cluster_id13\nCancer_P1_0           1               0            0            0            0\nCancer_P5_0           1               0            0            0            0\n            cluster_id14 cluster_id16 cluster_id17 cluster_id2 cluster_id3\nCancer_P1_0            0            0            0           0           0\nCancer_P5_0            0            0            0           0           0\n            cluster_id4 cluster_id5 cluster_id6 cluster_id8 cluster_id9\nCancer_P1_0           0           0           0           0           0\nCancer_P5_0           0           0           0           0           0\n            conditionNormal:cluster_id10 conditionNormal:cluster_id11\nCancer_P1_0                            0                            0\nCancer_P5_0                            0                            0\n            conditionNormal:cluster_id13 conditionNormal:cluster_id14\nCancer_P1_0                            0                            0\nCancer_P5_0                            0                            0\n            conditionNormal:cluster_id16 conditionNormal:cluster_id17\nCancer_P1_0                            0                            0\nCancer_P5_0                            0                            0\n            conditionNormal:cluster_id2 conditionNormal:cluster_id3\nCancer_P1_0                           0                           0\nCancer_P5_0                           0                           0\n            conditionNormal:cluster_id4 conditionNormal:cluster_id5\nCancer_P1_0                           0                           0\nCancer_P5_0                           0                           0\n            conditionNormal:cluster_id6 conditionNormal:cluster_id8\nCancer_P1_0                           0                           0\nCancer_P5_0                           0                           0\n            conditionNormal:cluster_id9\nCancer_P1_0                           0\nCancer_P5_0                           0\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\nCheck out the results:\n\nExtract gene-level results.\nCount how many DSP genes are significant at 5% FDR.\nTake the top 3 DSP genes and visualize their spatial expression across all samples using ggspavis::plotCoords().\nHow would you describe the spatial expression patterns of these genes? To help with interpretation, try looking up information about these genes (e.g., UniProt or the Human Protein Atlas) to get clues about which cell types or tissue domains they may highlight.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Extract gene-level results\ndsp_global &lt;- res_edgeR$gene_results\nhead(dsp_global, 3)\n\n        gene_id logFC.conditionNormal.cluster_id10\nSPIB       SPIB                          3.4415851\nSLITRK6 SLITRK6                          3.7154399\nUBE2C     UBE2C                          0.3256397\n        logFC.conditionNormal.cluster_id11 logFC.conditionNormal.cluster_id13\nSPIB                             -5.983395                         -0.4236515\nSLITRK6                          -5.075883                          0.4888250\nUBE2C                             2.249840                         -2.5062421\n        logFC.conditionNormal.cluster_id14 logFC.conditionNormal.cluster_id16\nSPIB                              6.151715                         -5.7511426\nSLITRK6                          -6.603245                          0.5934225\nUBE2C                             9.622368                         -4.8662120\n        logFC.conditionNormal.cluster_id17 logFC.conditionNormal.cluster_id2\nSPIB                             0.4004018                         -1.255224\nSLITRK6                          7.0008848                          3.086543\nUBE2C                            4.0294337                          1.098661\n        logFC.conditionNormal.cluster_id3 logFC.conditionNormal.cluster_id4\nSPIB                             1.160759                          2.046807\nSLITRK6                          2.686996                          1.267288\nUBE2C                            3.088812                          3.277094\n        logFC.conditionNormal.cluster_id5 logFC.conditionNormal.cluster_id6\nSPIB                             5.217929                        -0.5678032\nSLITRK6                          3.306325                         2.2850045\nUBE2C                            1.463769                         4.5273828\n        logFC.conditionNormal.cluster_id8 logFC.conditionNormal.cluster_id9\nSPIB                            3.1284376                          2.316966\nSLITRK6                         5.4204477                         -1.086872\nUBE2C                           0.2789153                          4.335590\n          logCPM        F       PValue         FDR\nSPIB    5.752220 6.337809 3.350024e-07 0.003687506\nSLITRK6 5.038332 6.030911 5.512791e-07 0.003687506\nUBE2C   4.731840 5.944750 9.567813e-07 0.004266607\n\n# Count significant DSP genes (at 5% FDR significance level)\ntable(dsp_global$FDR &lt;= 0.05)\n\n\nFALSE  TRUE \n13365    13 \n\n# Top 3 DSP genes\ngs &lt;- rownames(dsp_global)[seq_len(3)]\ngs\n\n[1] \"SPIB\"    \"SLITRK6\" \"UBE2C\"  \n\n\n\nplots &lt;- lapply(samples, \\(s) {\n  # Subset to sample s\n  spe_j &lt;- spe[, spe$sample_id == s]\n  \n  # Plot cluster \n  p_cluster &lt;- plotCoords(\n    spe_j,\n    annotate = \"cluster\",\n    in_tissue = NULL,\n    point_size = 0.05,\n    legend_position = \"none\") +\n    ggtitle(s) +\n    scale_color_manual(values = unname(pals::trubetskoy()))\n  \n  # Plots for each DSP gene\n  p_genes &lt;- lapply(gs, \\(g) {\n    plotCoords(\n      spe_j,\n      annotate = g,\n      point_size = 0.05,\n      in_tissue = NULL,\n      assay_name = \"logcounts\",\n      feature_names = \"Symbol\"\n    ) +\n      scale_color_gradientn(colors = pals::brewer.reds(n=12))\n  })\n  \n  # combine the cluster plot and 3 gene plots\n  c(p_cluster, p_genes)\n})\n\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n\nplots_flat &lt;- unlist(plots, recursive = FALSE)\nwrap_plots(plots_flat, ncol = 4)\n\n\n\n\n\n\n\n\n\n\nIndividual domain test\nThe global test tells us which genes show different spatial patterns globally, but it does not tell us which clusters drive the differences.\nTo identify the key spatial domain where expression changes across conditions, we use DESpace::individual_dsp(), which performs domain-specific DSP tests.\n\n# Focus on one cluster to decrease runtime in this exercise\nspe$c8 &lt;- factor(ifelse(spe$cluster == \"8\", 1, 0))\ndsp_clu &lt;- individual_dsp(spe,\n                      cluster_col = \"c8\",\n                      sample_col = \"sample_id\",\n                      condition_col = \"condition\")\n\nFilter low quality genes: \n\n\nmin_counts = 20; min_non_zero_spots = 10.\n\n\nThe number of genes that pass filtering is 13378.\n\n\nConducting tests for layer '0' against all other layers.\n\n\nDesign model: row names represent sample names, followed by underscores and cluster names.\n\n\n                (Intercept) conditionNormal cluster_id0\nCancer_P1_Other           1               0           0\nCancer_P5_Other           1               0           0\n                conditionNormal:cluster_id0\nCancer_P1_Other                           0\nCancer_P5_Other                           0\n\n\nConducting tests for layer '1' against all other layers.\n\nDesign model: row names represent sample names, followed by underscores and cluster names.\n\n\n                (Intercept) conditionNormal cluster_id1\nCancer_P1_Other           1               0           0\nCancer_P5_Other           1               0           0\n                conditionNormal:cluster_id1\nCancer_P1_Other                           0\nCancer_P5_Other                           0\n\n\nReturning results\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\n\nExtract the 4th top DSP gene.\nVisualize its expression across samples via ggspavis::plotCoords() or DESpace::FeaturePlot() and interpret the result.\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n# Select cluster id (because after binarization cluster 8 = \"1\")\nid_clu &lt;- \"1\"\n\n# DSP results for cluster 8\nhead(dsp_clu[[id_clu]], 5)\n\n          gene_id     logFC   logCPM        F       PValue       FDR\nRNF186     RNF186 -3.330877 4.941428 43.41863 0.0001043483 0.6649003\nVIL1         VIL1 -2.371649 7.117510 36.91333 0.0002551964 0.6649003\nSIGLEC10 SIGLEC10  2.567324 5.554622 36.61699 0.0002614359 0.6649003\nCOL12A1   COL12A1 -2.543965 6.903958 35.37749 0.0002945338 0.6649003\nDDAH1       DDAH1 -1.978593 7.162494 35.05049 0.0003042777 0.6649003\n\n# dsp_clu[[\"1\"]] stores DSP genes for cluster 8  (after binarization)\n# dsp_clu[[\"0\"]] stores DSP genes for all other regions (not useful here)\n# If full clusters are used originally, dsp_clu[[\"8\"]] would store cluster 8 results\n\n# Select the 4th top DSP genes\n(gs &lt;- rownames(dsp_clu[[id_clu]])[4])\n\n[1] \"COL12A1\"\n\n\n\n# Visualization\nplots &lt;- lapply(samples, \\(.) {\n  # Subset sample\n  spe_j &lt;- spe[, colData(spe)$sample_id == .]\n  # FeaturePlot for cluster 8\n  plot &lt;- FeaturePlot(spe_j, \n                      feature = gs, \n                      cluster_col = \"c8\", # binary cluster column\n                      cluster = \"1\",      # plot on cluster 8\n                      platform = \"VisiumHD\",\n                      sf_dim = 400,\n                      diverging = TRUE,\n                      point_size = 0.05,\n                      linewidth = 0.6) +\n    #scale_y_reverse() +\n    theme(legend.position = \"right\") +\n    labs(color = \"\") + ggtitle(.) \n  \n  return(plot)\n})\n\nCoordinate system already present.\nℹ Adding new coordinate system, which will replace the existing one.\nCoordinate system already present.\nℹ Adding new coordinate system, which will replace the existing one.\nCoordinate system already present.\nℹ Adding new coordinate system, which will replace the existing one.\nCoordinate system already present.\nℹ Adding new coordinate system, which will replace the existing one.\n\nwrap_plots(plots, ncol = 2) + plot_layout(guides = 'collect') + ggtitle(gs)\n\n\n\n\n\n\n\nIn CRC samples, COL12A1 shows higher expression in cluster 8 and covers a larger region. In normal samples, its expression is weaker and more limited.\nCluster 8 might correspond to a stromal region that becomes expanded or remodeled in CRC. individual_dsp() helps identify which spatial domain shows condition-specific changes in gene expression.\n\n\n\nClear your environment:\n\nrm(list = ls())\ngc()\n.rs.restartR()\n\n\n\n\n\n\n\nImportant\n\n\n\nKey Takeaways:\n\nDSP genes capture changes in where a gene is expressed across conditions, not only how much.\ndsp_test() identifies global DSP genes across all clusters and samples.\nindividual_dsp() pinpoints which clusters (spatial domains) drive these differences."
  },
  {
    "objectID": "qmd/about.html",
    "href": "qmd/about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "qmd/precourse_preparations.html",
    "href": "qmd/precourse_preparations.html",
    "title": "Precourse preparations",
    "section": "",
    "text": "You should meet the learning outcomes of:\n\nIntroduction to bulk RNA-Seq: From Quality Control to Pathway Analysis\nIntroduction to Sequencing Data Analysis\nFirst Steps with R in Life Sciences\nSingle-Cell Transcriptomics with R\n\nIn summary, participants must already have a basic knowledge in: - Next Generation Sequencing (NGS) techniques - Analyzing gene expression data - Dimensionality reduction (PCA, UMAP) - Graph-based clustering - R (evaluate your R skills here) - UNIX (self-assess your skills with the e-learning course UNIX Fundamentals, and this quiz)\n\n\n\nAttendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided. In order to access that environment your computer needs to be able to access http websites (not https). You can check this by browsing to http://www.httpforever.com. However, in case you wish to perform the practical exercises on your own computer, please take a moment to install the following before the course:\n\nR version &gt; 4.5.\nLatest RStudio version, the free version is perfectly fine.\nThe R packages necessary for the course. Find the renv to install them here."
  },
  {
    "objectID": "qmd/precourse_preparations.html#required-competences",
    "href": "qmd/precourse_preparations.html#required-competences",
    "title": "Precourse preparations",
    "section": "",
    "text": "You should meet the learning outcomes of:\n\nIntroduction to bulk RNA-Seq: From Quality Control to Pathway Analysis\nIntroduction to Sequencing Data Analysis\nFirst Steps with R in Life Sciences\nSingle-Cell Transcriptomics with R\n\nIn summary, participants must already have a basic knowledge in: - Next Generation Sequencing (NGS) techniques - Analyzing gene expression data - Dimensionality reduction (PCA, UMAP) - Graph-based clustering - R (evaluate your R skills here) - UNIX (self-assess your skills with the e-learning course UNIX Fundamentals, and this quiz)\n\n\n\nAttendees should have a Wi-Fi enabled computer. An online R and RStudio environment will be provided. In order to access that environment your computer needs to be able to access http websites (not https). You can check this by browsing to http://www.httpforever.com. However, in case you wish to perform the practical exercises on your own computer, please take a moment to install the following before the course:\n\nR version &gt; 4.5.\nLatest RStudio version, the free version is perfectly fine.\nThe R packages necessary for the course. Find the renv to install them here."
  }
]