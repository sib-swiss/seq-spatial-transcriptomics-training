---
title: "Exercise 2"
format: html
editor: source
editor_options: 
  chunk_output_type: console
---


## Quality Control at spot-level

In this second exercise, we will focus on the critical step of quality control (QC) for spatial transcriptomics data. This step focuses at removing low-quality spots or technical artifacts from the dataset to avoid biases into downstream analysis.



## Learning Objectives

By the end of this exercise, you will be able to:

- Calculate per-spot QC metrics.
- Identify local outliers based on various QC metrics.
- Detect spatial artifacts using `SpotSweeper`.
- Visualize QC metrics and detected artifacts.


## Libraries
```{r}
#| message: false
#| warning: false
#| output: false

library(SpatialExperiment)
library(qs2)
library(SpotSweeper)
library(scuttle)
library(ggplot2)
library(escheR) # For spatial plotting
library(HDF5Array)
```

## Calculate QC metrics

We will start calculating QC metrics that are also used in scRNA-seq data. 

We will start by loading our `SpatialExperiment` object, which has been saved as a `.qs2` file, and prepare it for quality control analysis.

> Juna: Maybe ask them what interesting functions can do scuttle package

```{r}
# Load the SpatialExperiment object from the .qs2 file.
# This object contains the processed spatial transcriptomics data.
spe <- qs_read("results/01_spe.qs2", nthreads = 1)

# Identify mitochondrial transcripts. These are often used as a QC metric.
# Genes starting with "MT-" are from the mitochondrial genome.
is.mito <- rownames(spe)[grepl("^MT-", rownames(spe))]

# Calculate per-spot QC metrics using scuttle's addPerCellQCMetrics function.
# This adds metrics like sum (total counts), detected (number of detected genes),
# and mitochondrial gene percentage to the colData of the SpatialExperiment object.
spe <- scuttle::addPerCellQCMetrics(spe, subsets = list(Mito = is.mito))

```


Next, have a look at the newly added metadata columns 

```{r}

# Display the column names of the colData to see the newly added QC metrics.
colnames(colData(spe))
```

What represent the new columns? 
:::{.callout-tip collapse="true"}
### Answer

- The `sum` column contains the total number of unique molecular identifiers (UMIs) for each spot
- The `detected` column contains the number of unique genes detected per spot
- The `subsets_mito_percent` contains the percentage of transcripts mapping to mitochondrial genes per spot
:::

# GLobal Outlier Detection

We will start using QC methods adapted from snRNA-seq analysis to identify potential low-quality spots.  
A simple option is to apply fixed thresholds to each QC metric across all spots, and remove the spots that do not pass the filering criteria applied.

QC metrics:
  
- Library size: 
- Number of expressed genes
- Proportion of Mt reads
- Number of spots per cell

We can have a look and plot distributions of the values to decide which is the best cutoff:

```{r}
# plot library size vs. detected genes
p1 <- plotObsQC(spe, 
                plot_type="scatter", 
                x_metric="detected", 
                y_metric="sum",
                y_threshold=600) + 
  ggtitle("Library size vs. detected")

# plot mito proportion vs. detected genes
p2 <- plotObsQC(spe, 
                plot_type="scatter", 
                x_metric="detected", 
                y_metric="subsets_Mito_percent", 
                y_threshold=30) + 
  ggtitle("Mito proportion vs. genes detected")

p1 | p2
```

And further check how many spots would be removed with given thresholds:

```{r}
spe$qc_lib_size <- spe$sum < 600
spe$qc_detected <- spe$detected < 400
spe$qc_mito_prop <- spe$subsets_Mito_percent > 30

# tabulate number of cells kept/flagged by each
qc <- grep("^qc", names(colData(spe)))
sapply(colData(spe)[qc], table)
```

## Question: Have a look at the library.size and detected genes numbers on the tissue section using plotVisium() function. Which spots are more likely to be excluded?

:::{.callout-tip collapse="true"}
### Answer

```{r}
plotVisium(spe, annotate = "sum", zoom = TRUE)
plotVisium(spe, spots=FALSE, zoom = TRUE)
```
:::

Very importantly, we want to have a look into the spatial pattern of the QC metrics before deciding on global thresholds:

```{r}
# check spatial pattern of discarded spots
p1 <- plotObsQC(spe, 
                plot_type="spot", annotate="qc_lib_size") + 
  ggtitle("Library size (< 600 UMI)")

p2 <- plotObsQC(spe, 
                plot_type="spot", annotate="qc_detected") + 
  ggtitle("Detected genes (< 400 genes)")

p3 <- plotObsQC(spe, 
                plot_type="spot", annotate="qc_mito_prop") + 
  ggtitle("Mito proportion (> 30%)")

p1 | p2 | p3
```


We can also address filtering based on local outlier detection, and remove spots that are outliers within their local biological neighborhood.

# Local Outlier Detection

## Quality Control using `SpotSweeper`


> Using the `SpotSweeper` package, we will learn how to identify and handle low-quality spots and spatial artifacts, which is essential for ensuring the reliability of downstream analyses. We will calculate various QC metrics, detect local outliers, and visualize the results to gain a comprehensive understanding of data quality.

Here, we identify local outliers based on common QC metrics such as library size, number of detected genes, and mitochondrial percentage. `localOutliers` from `SpotSweeper` helps in identifying spots that deviate significantly from their local neighborhood.

**Note:** this takes about 10 minutes to run. Have a coffee. 
> Julien: took a few seconds on the subsetted object

```{r}
# Identify local outliers based on library size ("sum" of counts).
# Spots with unusually low library size compared to their neighbors will be flagged.

spe <- localOutliers(spe,
  metric = "sum",
  direction = "lower",
  log = TRUE
)


# Identify local outliers based on the number of unique genes detected ("detected").
# Spots with an unusually low number of detected genes will be flagged.
spe <- localOutliers(spe,
  metric = "detected",
  direction = "lower",
  log = TRUE
)

# Identify local outliers based on the mitochondrial gene percentage.
# Spots with an unusually high mitochondrial percentage will be flagged.
spe <- localOutliers(spe,
  metric = "subsets_Mito_percent",
  direction = "higher",
  log = FALSE
)


# Combine all individual outlier flags into a single "local_outliers" column.
# A spot is considered a local outlier if it's flagged by any of the above metrics.
spe$local_outliers <- as.logical(spe$sum_outliers) |
  as.logical(spe$detected_outliers) |
  as.logical(spe$subsets_Mito_percent_outliers)
```

## Question 1

**How many spots were identified as local outliers based on the combined criteria?**
> Should we also run an outlier detection similar to scRNA-seq data, without spatial neighbourhood consideration? It would be interesting to discuss the benefit/shortcomnings of the spotSweeper approach (e.g., a whole low-quality region of a sample could be retained) related to naive filtering (e.g., whole cell types/domaisn could be excluded)

:::{.callout-tip collapse="true"}
### Answer

```r
# Count the number of spots flagged as local outliers.
table(spe$local_outliers)
```
:::

# Visualization of QC Results

Visualizing the QC metrics and detected artifacts is crucial for understanding the quality of your spatial transcriptomics data.

> Juna: maybe visualise also the detection measure like in OSTA book? and give first one as example, ask them to do the rest as a question

```{r}
# Plot the spatial distribution of local outliers.


# Spots flagged as local outliers will be highlighted.
plotQCmetrics(spe,
  metric = "subsets_Mito_percent", outliers = "subsets_Mito_percent_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers for %MT")

```

```{r}
plotQCmetrics(spe,
  metric = "sum_log", outliers = "sum_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers for number of UMIs")
```

```{r}
plotQCmetrics(spe,
  metric = "local_outliers", outliers = "local_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers excluded based on 3 criteria")
```


> Juna: add visualisation of z-scores as violin? Reflect how does are different than the common QC violins in scRNAseq? 
# Identify technical artifacts


> Juna: potentially add a comparison of filtering and adjust the global cutoffs:

```{r}
# adjust global filtering cutoff
spe$qc_lib_size <- spe$sum < 50
spe$qc_detected <- spe$detected < 10
spe$qc_mito_prop <- spe$subsets_Mito_percent > 35
```

# Evaluate global/local outliers

```{r}
spe$global_outliers <- spe$qc_lib_size | spe$qc_detected | spe$qc_mito_prop
plotObsQC(spe, plot_type="spot", annotate="global_outliers")
plotObsQC(spe, plot_type="spot", annotate="local_outliers")
```

Combine both and filter out genes with 0 counts

```{r}
# combine local and global outliers &
# remove combined set of low-quality spots
spe$discard <- 
    spe$global_outliers | 
    spe$local_outliers
table(spe$discard)

#save the non-filtered object for later
spe_nofilt <- spe
# remove the spots considered of low quality based on both global and local metrics
spe <- spe[, !spe$discard]

# remove features with all 0 counts
#spe <- spe[rowSums(counts(spe)) > 0, ]
dim(spe)
```

## Technical artifacts

Technical artifacts can arise during tissue preparation, for example tissue dissection can cause mechanical damage, leading to areas with artificially low biological heterogeneity. These can be detected wiht the `findArtifacts` function of the `spotSweeper` package.

> Juna: quite slow the findArtifacts

```{r}
# find artifacts using SpotSweeper
spe <- findArtifacts(spe,
    mito_percent = "subsets_Mito_percent",
    mito_sum = "subsets_Mito_sum",
    n_order = 5,
    name = "artifact"
)
```

## Question 2 
What is the `findArtifacts` function performing and what are the (potentially) problematic assumptions?

> Juna: there is no answer

## Question 3

**Plot the spatial distribution of the `artifact` column identified by `SpotSweeper`. What do you observe?**

:::{.callout-tip collapse="true"}
### Answer

```{r}
# Plot the spatial distribution of the detected artifacts.
plotQCmetrics(spe,
    metric = "subsets_Mito_percent", # You can choose any relevant metric to display
    outliers = "artifact", 
    point_size = 1.1
) +
    ggtitle("Detected Spatial Artifacts")
```
:::



# Save the object

```{r}
gc()
qs_save(spe, file = "results/01.2_spe.qs2")
```

Clear your environment

```{r}
#| eval: false
rm(list = ls())
gc()
.rs.restartR()
```

:::{.callout-important}
**Key Takeaways:**

-   `scuttle::addPerCellQCMetrics` provides essential per-spot QC metrics.
-   `SpotSweeper::localOutliers` helps identify individual problematic spots.
-   `SpotSweeper::findArtifacts` is powerful for detecting spatially coherent regions of poor quality.
-   Visualizing QC results is critical for data interpretation and downstream analysis decisions.
:::
