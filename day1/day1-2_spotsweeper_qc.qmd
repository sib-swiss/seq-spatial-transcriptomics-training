---
title: "Exercise 2"
format: html
editor: source
editor_options: 
  chunk_output_type: console
---


## Quality control at spot-level

In this second exercise, we will focus on the critical step of quality control (QC) for spatial transcriptomics data. This step focuses at removing low-quality spots or technical artifacts from the dataset to avoid biases into downstream analysis.



## Learning objectives

By the end of this exercise, you will be able to:

- Calculate per-spot QC metrics.
- Identify local outliers based on various QC metrics.
- Detect spatial artifacts using `SpotSweeper`.
- Visualize QC metrics and detected artifacts.


## Libraries
```{r}
#| message: false
#| warning: false
#| output: false

library(SpatialExperiment)
library(SpotSweeper)
library(scuttle)
library(ggplot2)
library(escheR) 
library(HDF5Array)
library(ggspavis)
library(patchwork)
```

## Calculate QC metrics

We will start calculating QC metrics that are also commonly used in scRNA-seq data (total counts, number of detected genes, mitochondrial percentage). These metrics will be used to identify low-quality spots.  

We will start by loading our `SpatialExperiment` object, which has been saved in the previous exercise, and prepare it for quality control analysis.  


```{r}
# Load the SpatialExperiment object
spe <- loadHDF5SummarizedExperiment(dir="results/day1/", prefix="01.1_spe")

# Identify mitochondrial genes (genes starting with "MT-")
is.mito <- rownames(spe)[grepl("^MT-", rownames(spe))]
```

Now, we will calculate per-spot QC metrics using the `scuttle` package. The function `addPerCellQCMetrics` adds metrics mitochondrial gene percentage to the `colData` of the `SpatialExperiment` object.

Run the following code to compute these metrics and inspect the results. 

```{r}
spe <- addPerCellQCMetrics(spe, subsets = list(Mito = is.mito))
```

**Question 1: Which metadata has been added to `colData`?**

:::{.callout-tip collapse="true"}
### Answer

```{r}
# Display the colData to see the newly added QC metrics.
colData(spe)
```

- The `sum` column contains the total number of unique molecular identifiers (UMIs) for each spot
- The `detected` column contains the number of unique genes detected per spot
- The `subsets_mito_percent` contains the percentage of transcripts mapping to mitochondrial genes per spot
:::


### Global outlier detection

In order to detect low-quality spots and filter them out, QC methods adapted from snRNA-seq analysis can be applied.
A simple option is to apply a fixed thresholds to each QC metric across all spots, and remove the spots that do not pass the filering criteria applied.

QC metrics:
  
- Library size: 
- Number of expressed genes
- Proportion of Mt reads

We can have a look and plot distributions of the values to decide which is the best cutoff:

```{r}
# Plot library size vs. detected genes
p1 <- plotObsQC(spe, 
                plot_type="scatter", 
                x_metric="detected", 
                y_metric="sum",
                y_threshold=600) + 
  ggtitle("Library size vs. detected")

# Plot mito proportion vs. detected genes
p2 <- plotObsQC(spe, 
                plot_type="scatter", 
                x_metric="detected", 
                y_metric="subsets_Mito_percent", 
                y_threshold=30) + 
  ggtitle("Mito proportion vs. genes detected")

p1 + p2
```

And further check how many spots would be removed with the given thresholds:

```{r}
# Flag spots based on fixed thresholds
spe$qc_lib_size <- spe$sum < 500
spe$qc_detected <- spe$detected < 400
spe$qc_mito_prop <- spe$subsets_Mito_percent > 30

# Tabulate number of spots flagged by each
qc <- grep("^qc", names(colData(spe)))
sapply(colData(spe)[qc], table)
```

**Question 2: Have a look at the mitochondrial percentage numbers on the tissue section using plotVisium() function. Which spots are more likely to be excluded?**

:::{.callout-tip collapse="true"}
### Answer

```{r}
plotVisium(spe, annotate = "subsets_Mito_percent", zoom = TRUE)
plotVisium(spe, spots=FALSE, zoom = TRUE)
```
:::

### Visualize spatial pattern of QC metrics (Global outliers)

Very importantly, we want to have a look into the spatial pattern of the QC metrics before deciding on global thresholds:

```{r}
# check spatial pattern of discarded spots
p1 <- plotObsQC(spe, 
                plot_type="spot", annotate="qc_lib_size") + 
  ggtitle("Library size (< 600 UMI)")

p2 <- plotObsQC(spe, 
                plot_type="spot", annotate="qc_detected") + 
  ggtitle("Detected genes (< 400 genes)")

p3 <- plotObsQC(spe, 
                plot_type="spot", annotate="qc_mito_prop") + 
  ggtitle("Mito proportion (> 30%)")

# plot the three together
gridExtra::grid.arrange(p1, p2, p3, ncol=2)
```



### Local Outlier Detection

Another approach to identify low-quality spots is to use local outlier detection methods that take into account the spatial context of each spot.

`SpotSweeper` package provides functions to identify common QC metrics (such as the ones we have seen in the previous section: library size, number of detected genes, and mitochondrial percentage) and detect local outliers based on these metrics.

We will use `localOutliers` from `SpotSweeper` which helps identifying spots that deviate significantly from their local neighborhood.


```{r}
# Identify local outliers based on library size ("sum" of counts).
# Spots with unusually low library size compared to their neighbors will be flagged.
spe <- localOutliers(spe,
  metric = "sum",
  direction = "lower",
  log = TRUE
)

# Identify local outliers based on the number of unique genes detected ("detected").
# Spots with an unusually low number of detected genes will be flagged.
spe <- localOutliers(spe,
  metric = "detected",
  direction = "lower",
  log = TRUE
)

# Identify local outliers based on the mitochondrial gene percentage.
# Spots with an unusually high mitochondrial percentage will be flagged.
spe <- localOutliers(spe,
  metric = "subsets_Mito_percent",
  direction = "higher",
  log = FALSE
)

# Combine all individual outlier flags into a single "local_outliers" column.
# A spot is considered a local outlier if it's flagged by any of the above metrics.
spe$local_outliers <- as.logical(spe$sum_outliers) |
  as.logical(spe$detected_outliers) |
  as.logical(spe$subsets_Mito_percent_outliers)
```

**Question 3: How many spots were identified as local outliers based on the combined criteria?**

:::{.callout-tip collapse="true"}
### Answer

```{r}
# Count the number of spots flagged as local outliers.
table(spe$local_outliers)
```
:::


### Visualize spatial pattern of QC metrics (Local outliers)

As we have seen before, visualizing the QC metrics is crucial for understanding the quality of your spatial transcriptomics data and for deciding on appropriate filtering strategies.  

> Juna: maybe add a visualisation step of the QC metrics on the slide before plotting the outliers?


Next, we will visualize the spatial distribution of the local outliers.

Highligh the spots that have been flagged as local outliers based on mitochondrial percentage.
```{r}
# Plot the spatial distribution of local outliers for mitochondrial percentage.
plotQCmetrics(spe,
  metric = "subsets_Mito_percent", outliers = "subsets_Mito_percent_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers for %MT")

```

**Question 4: Plot the spatial distribution of local outliers for library size and number of detected genes. What do you observe?**

:::{.callout-tip collapse="true"}
### Answer

```{r}
# Plot the spatial distribution of local outliers for library size.
plotQCmetrics(spe,
  metric = "sum_log", outliers = "sum_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers for number of UMIs")
```

```{r}
# Plot the spatial distribution of local outliers for number of detected genes.
plotQCmetrics(spe,
  metric = "detected_log", outliers = "detected_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers for number of UMIs")
```

:::

Plot the three metrics together:

```{r}
plotQCmetrics(spe,
  metric = "local_outliers", outliers = "local_outliers", point_size = 0.4,
  stroke = 0.75
) +
  ggtitle("Local outliers excluded based on 3 criteria")
```



> Juna: add visualisation of z-scores as violin? Reflect how those are different than the common QC violins in scRNAseq? 


## Compare and combine global and local outliers and apply filtering

> Juna: potentially add a comparison of filtering and adjust the global cutoffs:

Adjust global filtering cutoffs based on previous plots (apply less stringent cutoffs)

```{r}
# adjust global filtering cutoff
spe$qc_lib_size <- spe$sum < 50
spe$qc_detected <- spe$detected < 10
spe$qc_mito_prop <- spe$subsets_Mito_percent > 35
```

Compare global and local outliers being flagged

```{r}
spe$global_outliers <- spe$qc_lib_size | spe$qc_detected | spe$qc_mito_prop
p1 <- plotObsQC(spe, plot_type="spot", annotate="global_outliers")
p2 <- plotObsQC(spe, plot_type="spot", annotate="local_outliers")
gridExtra::grid.arrange(p1, p2, ncol=2)
```

Combine both and filter out genes with 0 counts

```{r}
# combine local and global outliers to create a final discard flag
spe$discard <- spe$global_outliers | spe$local_outliers
```

**Question 5: Visualise the spots that will be discarded based on the combined criteria. How many spots will be removed?**

:::{.callout-tip collapse="true"}
### Answer
```{r}
# check how many spots will be discarded
table(spe$discard)

# have a final look to the spots that we will discard
plotVisium(spe, zoom=T, annotate="discard")
```
:::

Finally, we can filter out the low-quality spots from the `SpatialExperiment` object based on the combined criteria of global and local outliers. Additionally, we will remove any features (genes) that have zero counts across all remaining spots.

```{r}
# remove the spots considered of low quality based on both global and local metrics
spe <- spe[, !spe$discard]

# remove features with all 0 counts
spe <- spe[rowSums(counts(spe)) > 0, ]
``` 


## Technical artifacts

Technical artifacts can arise during tissue preparation, for example tissue dissection can cause mechanical damage, leading to areas with artificially low biological heterogeneity. These can be detected wiht the `findArtifacts` function of the `spotSweeper` package.

```{r}
# find artifacts using SpotSweeper
spe <- findArtifacts(spe,
    mito_percent = "subsets_Mito_percent",
    mito_sum = "subsets_Mito_sum",
    n_order = 5,
    name = "artifact"
)
```

**Question 6: What is the `findArtifacts` function performing and what are the (potentially) problematic assumptions?**


> Juna: there is no answer


**Question 7: Plot the spatial distribution of the `artifact` column identified by `SpotSweeper`. What do you observe?**

:::{.callout-tip collapse="true"}
### Answer

```{r}
# Plot the spatial distribution of the detected artifacts.
plotQCmetrics(spe,
    metric = "subsets_Mito_percent", # You can choose any relevant metric to display
    outliers = "artifact", 
    point_size = 1.1
) +
    ggtitle("Detected Spatial Artifacts")
```
:::


## Save the object

Save the filtered `SpatialExperiment` object for the next steps:
```{r}
saveHDF5SummarizedExperiment(spe, dir="results/day1", prefix="01.2_spe", replace=TRUE,
                                chunkdim=NULL, level=NULL, as.sparse=NA,
                                verbose=NA)
```

Clear your environment:
```{r}
#| eval: false
rm(list = ls())
gc()
.rs.restartR()
```

:::{.callout-important}
**Key Takeaways:**

-   `scuttle::addPerCellQCMetrics` provides essential per-spot QC metrics.
-   `SpotSweeper::localOutliers` helps identify individual problematic spots.
-   `SpotSweeper::findArtifacts` is powerful for detecting spatially coherent regions of poor quality.
-   Visualizing QC results is critical for data interpretation and downstream analysis decisions.
:::
